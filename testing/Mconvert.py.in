#!@PYTHON@

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0.  If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# Copyright 1997 - July 2008 CWI, August 2008 - 2022 MonetDB B.V.

#TODO:
#=====
# - check all TODO's below
# - tidy -up HTML-generation by "keeping in mind" during testing,
#   which OUT/ERR differ or not and which tests were skipped.
#   dump HTML-stuff only at end
#   print an ascii summary at end, too
# - if no diffs, but warnings, say so at end
# - produce, keep & reference LOG
# - add a "grep-like" function and replace "inlined" grep
#   contains(<file>,<string>)
# - do multi-level prompting?
# - normalize all path's used
# - Python 3? (or do a full rewrite?)

import os
import sys
import shutil
import re
import random
import time
import socket
import struct
import signal
import fnmatch
import glob

try:
    import winreg               # Python 3 on Windows
except ImportError:
    winreg = None               # not on Windows

MonetDB_VERSION = '@MONETDB_VERSION@'.split('.')

procdebug = False
verbose = False
quiet = False

initdb = None

global_timeout = 0
start_time = time.time()

# whether output goes to a tty
isatty = os.isatty(sys.stdout.fileno())

# default is no color (these three functions may get redefined)
def prred(str, write = sys.stdout.write):
    write(str)
def prgreen(str, write = sys.stdout.write):
    write(str)
def prpurple(str, write = sys.stdout.write):
    write(str)
if isatty:
    if os.name != 'nt':
        # color output a little
        RED = '\033[1;31m'
        GREEN = '\033[0;32m'
        PURPLE = '\033[1;35m'       # actually magenta
        BLACK = '\033[0;0m'
        def prred(str, write = sys.stdout.write):
            try:
                write(RED)
                write(str)
            finally:
                write(BLACK)
        def prgreen(str, write = sys.stdout.write):
            try:
                write(GREEN)
                write(str)
            finally:
                write(BLACK)
        def prpurple(str, write = sys.stdout.write):
            try:
                write(PURPLE)
                write(str)
            finally:
                write(BLACK)
    else:
        try:
            import ctypes
        except ImportError:
            pass
        else:
            STD_OUTPUT_HANDLE = -11
            try:
                handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
            except AttributeError:
                pass
            else:
                def get_csbi_attributes(handle):
                    # Based on IPython's winconsole.py, written by Alexander Belchenko
                    csbi = ctypes.create_string_buffer(22)
                    res = ctypes.windll.kernel32.GetConsoleScreenBufferInfo(handle, csbi)
                    assert res
                    (bufx, bufy, curx, cury, wattr,
                    left, top, right, bottom, maxx, maxy) = struct.unpack("hhhhHhhhhhh", csbi.raw)
                    return wattr
                reset = get_csbi_attributes(handle)
                def prred(str,
                          write=sys.stdout.write,
                          flush=sys.stdout.flush,
                          scta=ctypes.windll.kernel32.SetConsoleTextAttribute):
                    try:
                        flush()
                        scta(handle, 0x4)
                        write(str)
                        flush()
                    finally:
                        scta(handle, reset)
                def prgreen(str,
                            write=sys.stdout.write,
                            flush=sys.stdout.flush,
                            scta=ctypes.windll.kernel32.SetConsoleTextAttribute):
                    try:
                        flush()
                        scta(handle, 0x2)
                        write(str)
                        flush()
                    finally:
                        scta(handle, reset)
                def prpurple(str,
                             write=sys.stdout.write,
                             flush=sys.stdout.flush,
                             scta=ctypes.windll.kernel32.SetConsoleTextAttribute):
                    try:
                        flush()
                        scta(handle, 0x5)
                        write(str)
                        flush()
                    finally:
                        scta(handle, reset)

if os.path.exists('/usr/bin/coredumpctl'):
    # probably Linux if /usr/bin/coredumpctl exists
    # try raising the core dump size limit to infinite so that when we
    # get a crash we have a chance to retrieve the stack trace
    try:
        import resource
    except ImportError:
        pass
    else:
        try:
            resource.setrlimit(resource.RLIMIT_CORE,
                               (resource.RLIM_INFINITY,
                                resource.getrlimit(resource.RLIMIT_CORE)[1]))
        except ValueError:
            # if we can't raise the limit, just forget it
            pass

def ErrExit(msg):
    sys.stderr.write(msg + '\n')
    sys.exit(1)

def _configure(str):
    # expand configure variables in str and return result
    config = [
        ('{source}', '@QXSOURCE@'),
        ('${build}', '@QXBUILD@'),

        ('${bindir}', '@QXbindir@'),
##        ('${sbindir}', '@QXsbindir@'),
        ('${libexecdir}', '@QXlibexecdir@'),
        ('${datarootdir}', '@QXdatarootdir@'),
        ('${datadir}', '@QXdatadir@'),
        ('${sysconfdir}', '@QXsysconfdir@'),
        ('${localstatedir}', '@QXlocalstatedir@'),
        ('${libdir}', '@QXlibdir@'),
        ('${includedir}', '@QXincludedir@'),
##        ('${oldincludedir}', '@QXoldincludedir@'),
        ('${infodir}', '@QXinfodir@'),
        ('${mandir}', '@QXmandir@'),
        ('${Qbindir}', '@QXbindir@'),
##        ('${Qsbindir}', '@QXsbindir@'),
        ('${Qlibexecdir}', '@QXlibexecdir@'),
        ('${Qdatarootdir}', '@QXdatarootdir@'),
        ('${Qdatadir}', '@QXdatadir@'),
        ('${Qsysconfdir}', '@QXsysconfdir@'),
        ('${Qlocalstatedir}', '@QXlocalstatedir@'),
        ('${Qlibdir}', '@QXlibdir@'),
        ('${Qincludedir}', '@QXincludedir@'),
##        ('${Qoldincludedir}', '@QXoldincludedir@'),
        ('${Qinfodir}', '@QXinfodir@'),
        ('${Qmandir}', '@QXmandir@'),
        # put these at end (in this order!) for efficiency
        ('${exec_prefix}', '@QXexec_prefix@'),
        ('${Qexec_prefix}', '@QXexec_prefix@'),
        ('${prefix}', '@QXprefix@'),
        ('${Qprefix}', '@QXprefix@'),
        ]
    if os.name == 'nt':
        str = str.replace('%prefix%', '${prefix}')
        str = str.replace('%exec_prefix%', '${exec_prefix}')
    changed = True
    while '$' in str and changed:
        changed = False
        for key, val in config:
            if os.name == 'nt':
                val = val.replace('%prefix%', '${prefix}')
                val = val.replace('%exec_prefix%', '${exec_prefix}')
            nstr = str.replace(key, val)
            changed = changed or str != nstr
            str = nstr
    return str

try:
    from helpers import build_work_ctx
except ImportError:
    try:
        from MonetDBtesting.helpers import build_work_ctx
    except ImportError:
        p = _configure(os.path.join('@QXprefix@', '@QXPYTHON_LIBDIR@'))
        sys.path.insert(0, p)
        from MonetDBtesting.helpers import build_work_ctx
        if 'PYTHONPATH' in os.environ:
            p += os.pathsep + os.environ['PYTHONPATH']
        os.environ['PYTHONPATH'] = p

# use our own process module because it has _BufferedPipe
try:
    import process
except ImportError:
    try:
        import MonetDBtesting.process as process
    except ImportError:
        p = _configure(os.path.join('@QXprefix@', '@QXPYTHON_LIBDIR@'))
        sys.path.insert(0, p)
        import MonetDBtesting.process as process
        if 'PYTHONPATH' in os.environ:
            p += os.pathsep + os.environ['PYTHONPATH']
        os.environ['PYTHONPATH'] = p

# Replace os.fork by a version that forks but also sets the process
# group in the child.  This is done so that we can easily kill a
# subprocess and its children in case of a timeout.
# To use this, set the global variable setpgrp to True before calling
# subprocess.Popen.  It is reset automatically to False so that
# subprocess of our child don't get their own process group.
try:
    os.setpgrp
except AttributeError:
    try:
        os.setpgid
    except AttributeError:
        # no function to set process group, so don't replace
        pass
    else:
        # use os.setpgid to set process group
        def myfork(osfork = os.fork):
            global setpgrp
            _setpgrp = setpgrp
            setpgrp = False
            pid = osfork()
            if pid == 0 and _setpgrp:
                os.setpgid(0, 0)
            return pid
        os.fork = myfork
else:
    # use os.setpgrp to set process group
    def myfork(osfork = os.fork):
        global setpgrp
        _setpgrp = setpgrp
        setpgrp = False
        pid = osfork()
        if pid == 0 and _setpgrp:
            os.setpgrp()
        return pid
    os.fork = myfork
setpgrp = False

try:
    ttywidth = os.get_terminal_size(1).columns
except:
    ttywidth = 0
else:
    if ttywidth > 0 and os.name == 'nt':
        ttywidth -= 1           # don't go to the edge

import string                   # for whitespace
def splitcommand(cmd):
    '''Like string.split, except take quotes into account.'''
    q = None
    w = []
    command = []
    for c in cmd:
        if q:
            if c == q:
                q = None
            else:
                w.append(c)
        elif c in string.whitespace:
            if w:
                command.append(''.join(w))
            w = []
        elif c == '"' or c == "'":
            q = c
        else:
            w.append(c)
    if w:
        command.append(''.join(w))
    if len(command) > 1 and command[0] == 'call':
        del command[0]
    return command

def remove(file):
    try:
        os.remove(file)
    except:
        pass

def isexecutable(TST, ext = '.sh') :
    if   os.name == "nt":
        for ext in ".exe", ".com", ".bat", ".cmd":
            if TST.lower().endswith(ext):
                ext = ''
            if os.path.isfile(TST+ext) or os.path.isfile(TST+ext+".src"):
                return (True, ext)
    elif os.name == "posix":
        #TODO:
        # check with "file", and set executable
        TST += ext
        if ( os.path.isfile(TST       ) and os.access(TST       ,os.X_OK) ) or \
           ( os.path.isfile(TST+".src") and os.access(TST+".src",os.X_OK) ):
            return (True, ext)
    #TODO:
    #else:
        # ???
    return (False, '')
### isexecutable(TST, ext = '.sh') #

def CheckExec(cmd) :
    for p in os.environ['PATH'].split(os.pathsep):
        x = isexecutable(os.path.join(p,cmd),'')
        if x[0]:
            return os.path.join(p, cmd + x[1])
    return ""
### CheckExec(cmd) #

import argparse

import threading

randomPortRepeat = 9

F_SKIP = -1
F_OK = 0
F_WARN = 1
F_SOCK = 2
F_MISSING = 3
F_ERROR = 4
F_TIME = 5
F_ABRT = 6
F_RECU = 7
F_SEGV = 8

FAILURES = {
    F_SKIP  : ("F_SKIP",  '-'),
    F_OK    : ("F_OK",    'o'),
    F_WARN  : ("F_WARN",  'x'),
    F_SOCK  : ("F_SOCK",  'S'),
    F_ERROR : ("F_ERROR", 'X'),
    F_TIME  : ("F_TIME",  'T'),
    F_ABRT  : ("F_ABRT",  'A'),
    F_RECU  : ("F_RECU",  'R'),
    F_SEGV  : ("F_SEGV",  'C'),
    F_MISSING: ("F_MISSING", 'M'),
}

CONDITIONALS = {
    # X == true   =>  @X_TRUE@='',  @X_FALSE@='#'
    # X == false  =>  @X_TRUE@='#', @X_FALSE@=''
    # from configure.ag:
    # These should cover all AM_CONDITIONALS defined in configure.ag, i.e.,
    # `grep AM_CONDITIONAL configure.ag | sed 's|^AM_CONDITIONAL(\([^,]*\),.*$|\1|' | sort -u`
    'BITS32'               : "@BITS32_FALSE@",
    'BITS64'               : "@BITS64_FALSE@",
    'CROSS_COMPILING'      : "@CROSS_COMPILING_FALSE@",
    'HAVE_CURL'            : "@HAVE_CURL_FALSE@",
    'HAVE_FITS'            : "@HAVE_FITS_FALSE@",
    'HAVE_GEOM'            : "@HAVE_GEOM_FALSE@",
    'HAVE_HGE'             : "@HAVE_HGE_FALSE@",
    'HAVE_LIBBZ2'          : "@HAVE_LIBBZ2_FALSE@",
    'HAVE_LIBLZ4'          : "@HAVE_LIBLZ4_FALSE@",
    'HAVE_LIBLZMA'         : "@HAVE_LIBLZMA_FALSE@",
    'HAVE_LIBPCRE'         : "@HAVE_LIBPCRE_FALSE@",
    'HAVE_LIBPY3'          : "@HAVE_LIBPY3_FALSE@",
    'HAVE_LIBR'            : "@HAVE_LIBR_FALSE@",
    'HAVE_LIBXML'          : "@HAVE_LIBXML_FALSE@",
    'HAVE_LIBZ'            : "@HAVE_LIBZ_FALSE@",
    'HAVE_MAL_DEBUGGER'    : "@HAVE_MAL_DEBUGGER_FALSE@",
    'HAVE_NETCDF'          : "@HAVE_NETCDF_FALSE@",
    'HAVE_ODBC'            : "@HAVE_ODBC_FALSE@",
    'HAVE_PROJ'            : "@HAVE_PROJ_FALSE@",
    'HAVE_SHP'             : "@HAVE_SHP_FALSE@",
    'NATIVE_WIN32'         : "@NATIVE_WIN32_FALSE@",
    'NOT_WIN32'            : "@NOT_WIN32_FALSE@",
    'NOT_ASSERT'           : "@NOT_ASSERT_FALSE@",
    # unknown at compile time;
    # hence, we set them only at runtime in main() below
    'KNOWNFAIL'            : "", # skip on release branch when not in testweb
    'HAVE_MONETDBJDBC_JAR' : "",
    'HAVE_JAVA'            : "",
    'HAVE_JAVAJDBC'        : "",
    'HAVE_JAVAMEROCONTROL' : "",
    'HAVE_JDBCCLIENT_JAR'  : "",
    'HAVE_JDBCTESTS_JAR'   : "",
    'HAVE_JDBCTESTS_DIR'   : "",
    'HAVE_JDBCTESTS'       : "",
#    'HAVE_LIBPANDAS3'      : "",
    'HAVE_LIBSCIPY3'       : "",
    'HAVE_PERL'            : "",
    'HAVE_PHP'             : "",
    'HAVE_PYMONETDB'       : "", # default PYTHON can import pymonetdb
    'HAVE_PY3MONETDB'      : "", # PYTHON3 exists and can import pymonetdb
    'HAVE_PYTHON_LZ4'      : "", # module lz4 is available
    'HAVE_RUBY'            : "",
    'HAVE_DATA_PATH'       : "",
    'MERCURIAL'            : "",
    'RELEASERUN'           : "",
    'BAD_HOSTNAME'         : "",
    'HAVE_IPV6'            : "",
}


class Timer:
    # interface to the threading.Timer function that interprets a
    # timeout of 0 as no timeout
    def __init__(self, interval, function, args):
        self.timer = None
        if interval > 0:
            self.timer = threading.Timer(interval, function, args = args)

    def start(self):
        if self.timer is not None:
            self.timer.start()

    def cancel(self):
        if self.timer is not None:
            self.timer.cancel()

STDOUT = sys.stdout
STDERR = sys.stdout     # err
REV = ''                # revision (output of hg id), default unknown

black = 'black'                         # #000000
white = 'white'                         # #ffffff
red = 'red'                             # #ff0000
lime = 'lime'                           # #00ff00
green = '#00aa00'
darkgreen = '#005500'
orange = '#ffaa00'
purple = '#aa00aa'

TIMES = []

random.seed(time.time())

def ErrMsg(TEXT) :
    STDOUT.flush()
    STDERR.write("\n%s:  ERROR:  %s\n\n" % (THISFILE, TEXT))
    STDERR.flush()
### ErrMsg(TEXT) #

def ErrXit(TEXT) :
    ErrMsg(TEXT)
    sys.exit(1)
### ErrXit(TEXT) #

def Warn(TEXT) :
    try:
        STDOUT.flush()
    except IOError:
        pass
    try:
        STDERR.write("\n%s  Warning:  %s\n\n" % (THISFILE, TEXT))
        STDERR.flush()
    except IOError:
        pass
### Warn(TEXT) #

def startswithpath(str,pre) :
    return os.path.normcase(str[:len(pre)]) == os.path.normcase(pre)
### startswithpath(str,pre) #

import urllib.request
path = urllib.request.url2pathname
def url(str) :
    url = urllib.request.pathname2url(str)
    # on Windows, C:\tmp\foo becomes ///C:/tmp/foo, turn into /C:/tmp/foo
    if url.startswith('///'):
        url = url[2:]
    return url

def openutf8(file, mode='r'):
    return open(file, mode, encoding='utf-8', errors='replace')

def try_open(path, mode) :
    try:
        f = openutf8(path, mode)
    except IOError as err:
        Warn("Opening file '%s' in mode '%s' failed with #%d: '%s'." % (path, mode, err.errno, err.strerror))
        f = None
    return f
###  try_open(path, mode) #

bugre = re.compile(r'\.(sf|bug)-(?P<bugno>[1-9]\d+)', re.I)


def find_test_dirs(thisdir) :
    testdirs = []
    thisdir = os.path.realpath(thisdir)
    dirnme = os.path.basename(thisdir)
    dirlst = listdir(thisdir)
    if dirnme == TSTSUFF  and  "All" in dirlst  and  os.path.isfile(os.path.join(thisdir,"All")):
        testdirs.append(os.path.dirname(thisdir))
    for d in dirlst:
        d = os.path.join(thisdir,d)
        if os.path.isdir(d):
            testdirs = testdirs + find_test_dirs(d)
    return testdirs
### find_test_dirs(thisdir) #

def PerformDir(env, testdir, auto=False) :
    oneserver = testdir.get('single_server', False)
    options = testdir.get('server_options', [])
    testlist = testdir.get('tests', [])

    TSTDIR = testdir.get('realpath')[len(TSTSRCBASE + os.sep):-len(os.sep + TSTSUFF)]
    TSTSRCDIR = testdir.get('realpath')
    TSTTRGDIR = os.path.normpath(os.path.join(TSTTRGBASE, TSTPREF, TSTDIR))

    TSTDB = TSTPREF + "_" + TSTDIR.replace(os.sep, '_')

    env['TSTDB']     = TSTDB
    env['TSTDIR']    = TSTDIR
    env['TSTSRCDIR'] = TSTSRCDIR
    env['UTSTSRCDIR'] = 'file://' + url(TSTSRCDIR)
    env['TSTTRGDIR'] = TSTTRGDIR
    if TSTDIR == os.curdir:
        env['RELSRCDIR'] = os.path.join(os.pardir, env['RELSRCBASE'], TSTSUFF)
    else:
        env['RELSRCDIR'] = testdir.get('realpath')
    os.environ['TSTDB']     = TSTDB
    os.environ['TSTDIR']    = TSTDIR
    os.environ['TSTSRCDIR'] = TSTSRCDIR
    os.environ['TSTTRGDIR'] = TSTTRGDIR
    os.environ['RELSRCDIR'] = env['RELSRCDIR']
    if 'TSTDATAPATH' not in os.environ and TSTDATAPATH:
        env['TSTDATAPATH'] = TSTDATAPATH
        os.environ['TSTDATAPATH'] = TSTDATAPATH

    if 'GDK_DBFARM' in env:
        LogDBdir = os.path.join(env['GDK_DBFARM'],TSTDB)
        if not env.get('NOCLEAN') and LogDBdir and os.path.exists(LogDBdir):
            try:
                shutil.rmtree(LogDBdir)
            except:
                raise SystemExit("database '%s` exists, but destroying it failed; skipping tests in '%s`!" % (TSTDB, TSTSRCDIR))
        if os.path.isabs(LogDBdir) and not os.path.exists(LogDBdir):
            try:
                os.makedirs(LogDBdir)
            except:
                raise SystemExit("creating database '%s` failed; skipping tests in '%s`!" % (TSTDB, TSTSRCDIR))
        if initdb:
            import zipfile
            try:
                z = zipfile.ZipFile(initdb)
            except IOError:
                raise SystemExit("initial database '%s` cannot be opened; skipping tests in '%s`!" % (initdb, TSTSRCDIR))
            try:
                z.extractall(LogDBdir)
            except:
                raise SystemExit("initial database '%s` cannot be extracted; skipping tests in '%s`!" % (initdb, TSTSRCDIR))
            z.close()
            if not oneserver:
                pSrvr = ServerClass(splitcommand(env['exe']['mserver5'][1]) + ['--dbpath=%s' % LogDBdir], open(os.devnull, 'w'), open(os.devnull, 'w'), par['TIMEOUT'], os.path.join(LogDBdir, '.started'), int(env['MAPIPORT']))
                pSrvr.LaunchIt()
                pSrvr.terminate()
    if not os.path.exists(TSTTRGDIR):
        #TODO: set mode to umask
        os.makedirs(TSTTRGDIR)

    pSrvr = None
    BACK = os.getcwd()
    for t in testlist:
        fix = {}
        CALL = t.get('call')
        if CALL not in ['sql', 'mal']:
            continue
        test_name = t.get('test_name')
        options += t.get('options5', [])
        is_reqtest = t.get('is_reqtest', False)
        fn = t.get('test_path') + t.get('tail')
        if verbose:
            print('converting {}'.format(test_name), file=sys.stderr)

        COND = t.get('cond', None)
        if (COND != None and "HAVE_LIBR" in COND) and CONDITIONALS['HAVE_LIBR'] and CONDITIONALS['NOT_WIN32']:
            options.extend(['--set', 'embedded_r=yes'])
        if (COND != None and "HAVE_LIBPY3" in COND) and CONDITIONALS['HAVE_LIBPY3']:
            options.extend(['--set', 'embedded_py=3'])
        options.extend(['--set', 'embedded_c=true'])
        USER = 'monetdb'
        PASSWD = 'monetdb'
        if COND:
            for cond in COND.split('&'):
                if cond.startswith('USER='):
                    USER = cond[5:]
                elif cond.startswith('PASSWD='):
                    PASSWD = cond[7:]
        try:
            f = openutf8(os.path.join(os.path.dirname(t.get('test_path')), 'SingleServer'))
        except IOError:
            pass
        else:
            options.extend(f.read().split())
            f.close()
        try:
            with open('/tmp/sqllogic.in', 'w') as fout:
                if t.get('is_input', False):
                    with open(fn, 'r') as f:
                        for l in f:
                            expanded = expandvars(l, env)
                            print(expanded, file=fout)
                            if expanded != l:
                                fix[expanded] = l
                elif t.get('is_src_link', False):
                    with open(fn, 'r') as f:
                        fpath = expandvars(f.readline().strip(), env)
                        if os.path.isfile(fpath):
                            with open(fpath, 'r') as f:
                                print(f.read(), file=fout)
                        else:
                            os.chdir(TSTSRCDIR)
                            with open(fpath, 'r') as f:
                                print(f.read(), file=fout)
                            os.chdir(BACK)
                else:
                    with open(fn, 'r') as f:
                        print(f.read(), file=fout)
            if pSrvr is None:
                pSrvr = create_mserver5(
                        LogDBdir,
                        env=env,
                        outfile=os.path.join(TSTTRGDIR, 'SingleServer.out'),
                        errfile=os.path.join(TSTTRGDIR, 'SingleServer.err'),
                        options=options)
                pSrvr.LaunchIt()
            with open('/tmp/sqllogic.in', 'r') as fin:
                cmd = ['mktest.py', '--database', TSTDB, '--port', str(pSrvr.port), '--language', CALL, '--user', USER, '--password', PASSWD]
                with process.Popen(cmd, stdin=fin, stdout=process.PIPE, text=True) as proc:
                    if auto:
                        is_input = t.get('is_input', False)
                        if CALL == 'sql':
                            if is_input:
                                ext = '.test.in'
                            else:
                                ext = '.test'
                        else:
                            ext = '.maltest'
                        with open(t.get('test_path') + ext, 'w') as fout:
                            print(proc.stdout.read(), file=fout)
                            if len(fix.keys()) > 0:
                                print('-- WARNING expanded variables needs to be converted back', file=fout)
                                # print to stdout to make it obvious
                                print('-- WARNING expanded variables needs to be converted back in {}'.format(t.get('test_path') + ext))
                                for k in fix:
                                    print('--', k,':', fix[k], file=fout)
                    else:
                        print(proc.stdout.read())
                        if len(fix.keys()) > 0:
                            print('-- WARNING expanded variables needs to be converted back')
                            for k in fix:
                                print('--', k,':', fix[k])
        finally:
            if pSrvr is not None:
                pSrvr.terminate()
                pSrvr = None

    #--------------------------------------------
    #for t in testdir.get('tests', []):
    #    if t.get('call') != 'sql':
    #        raise SystemExit('ERROR: {} only sql tests can be squashed!'.format(t.get('name')))
    #    fn = t.get('test_path') + t.get('tail')
    #    if t.get('is_input', False):
    #        one_or_more_inputs = True
    #        with open(fn, 'r') as f:
    #            for l in f:
    #                expanded = expandvars(l, env)
    #                print(expanded)
    #                if expanded != l:
    #                    fix[expanded] = l
    #        continue
    #    if t.get('is_src_link', False):
    #        with open(fn, 'r') as f:
    #            fpath = expandvars(f.readline().strip(), env)
    #            if os.path.isfile(fpath):
    #                with open(fpath, 'r') as f:
    #                    print(f.read())
    #            else:
    #                os.chdir(TSTSRCDIR)
    #                with open(fpath, 'r') as f:
    #                    print(f.read())
    #                os.chdir(BACK)
    #        continue
    #    with open(fn, 'r') as f:
    #        print(f.read())
    #if one_or_more_inputs:
    #    print('-- WARNING expanded variables needs to be converted back')
    #    for k in fix:
    #        print('--', key,':', fix[key])

### PerformDir(env, testdir) #


# this function is a slightly modified copy of the posixpath version
# the differences are the doubling of \'s in the replacement value
# under a very specific condition: when the variable name starts with
# a Q and the variable name (with Q prefix) does not occur in the
# environment and the variable name minus the Q prefix does occur in
# the environment; and the addition of an extra parameter with default
# so that the environment which is used to expand can be replace.
_varprog = None
def expandvars(path, environ = os.environ):
    """Expand shell variables of form $var and ${var}.  Unknown variables
    are left unchanged."""
    global _varprog
    if '$' not in path:
        return path
    if not _varprog:
        import re
        _varprog = re.compile(r'\$(\w+|\{[^}]*\})')
    i = 0
    while True:
        m = _varprog.search(path, i)
        if not m:
            break
        i, j = m.span(0)
        name = m.group(1)
        if name.startswith('{') and name.endswith('}'):
            name = name[1:-1]
        if name in environ:
            tail = path[j:]
            val = environ[name]
            path = path[:i] + val
            i = len(path)
            path += tail
        elif name.startswith('Q') and name[1:] in environ:
            tail = path[j:]
            val = environ[name[1:]].replace('\\', '\\\\')
            path = path[:i] + val
            i = len(path)
            path += tail
        else:
            i = j
    return path

def coredumpctl(pid):
    import tempfile
    # can't use tempfile.NamedTemporaryFile because it opens the file
    # exclusively
    fd, name = tempfile.mkstemp(suffix='.sh')
    fd2, name2 = tempfile.mkstemp()
    os.close(fd2)
    os.write(fd, b'#!/bin/sh\ngdb -nx -batch -ex "thread apply all bt" "$@" > %s\n' % name2.encode('utf-8'))
    os.close(fd)
    os.chmod(name, 0o700)
    if procdebug:
        print('Starting: coredumpctl -q --debugger=%s gdb %d' % (name, pid))
    with process.Popen(['coredumpctl', '-q', '--debugger=%s' % name, 'gdb', str(pid)],
                       stdout=process.PIPE,
                       stderr=process.PIPE,
                       text=True) as p:
        out, err = p.communicate()
    os.unlink(name)
    s = []
    for l in out.split('\n'):
        if not l.startswith('                '):
            s.append(l)
    out = '\n'.join(s) + open(name2).read()
    os.unlink(name2)
    return out, err

def transform_str_return_code(code):
    lookup = {
            'abort': F_ABRT,
            'error': F_ERROR,
            'segfault': F_SEGV,
            'timeout': F_TIME,
            'socket': F_SOCK,
            'recursion': F_RECU}
    return lookup.get(code, F_ERROR) if code is not None else F_OK

def returnCode(proc, f = None):
    '''Interpret the return code of a process.
    If second arg sepcified, write a message to it.'''
    if proc.killed:
        # don't write for timeout, killProc did that already
        return 'timeout'
    if os.name == 'nt':
        if proc.returncode == 3:
            # heuristic: abort() causes exit code 3
            if f is not None:
                f.write('\nAborted\n')
                f.flush()
            return 'abort'
        if proc.returncode == -1073741819: # 0xC0000005
            if f is not None:
                f.write('\nSegmentation fault\n')
                f.flush()
            return 'segfault'
        if proc.returncode == -1073741510: # 0xC000013A
            if f is not None:
                f.write('\nInterrupt\n')
                f.flush()
            return 'interrupt'  # Interrupt
        if proc.returncode != 0:
            return 'error'
    else:
        if proc.returncode == -signal.SIGSEGV:
            if f is not None:
                f.write('\nSegmentation fault\n')
                if os.path.exists('/usr/bin/coredumpctl'):
                    # wait a few seconds for the core to be dumped
                    time.sleep(10)
                    out, err = coredumpctl(proc.pid)
                    if out:
                        f.write(out)
                f.flush()
            return 'segfault'   # Segmentation fault
        if proc.returncode == -signal.SIGBUS:
            if f is not None:
                f.write('\nBus error\n')
                f.flush()
            return 'segfault'   # Bus error, treat as segfault
        if proc.returncode == -signal.SIGABRT:
            if f is not None:
                f.write('\nAborted\n')
                if os.path.exists('/usr/bin/coredumpctl'):
                    # wait a few seconds for the core to be dumped
                    time.sleep(10)
                    out, err = coredumpctl(proc.pid)
                    if out:
                        f.write(out)
                f.flush()
            return 'abort'      # Aborted
        if proc.returncode == -signal.SIGINT:
            if f is not None:
                f.write('\nInterrupt\n')
                f.flush()
            return 'interrupt'  # Interrupt
        if proc.returncode < 0:
            if f is not None:
                f.write('\nSignal %d\n' % -proc.returncode)
                f.flush()
            return 'signal'     # some other signal
        if proc.returncode > 0:
            return 'error'
    return None                 # no error

def GetBitsAndModsAndThreads(env) :
    global setpgrp
    rtrn = 0
    cmd = splitcommand(env['exe']['mserver5'][1])
    dbpath = os.path.join(env['GDK_DBFARM'], TSTPREF)
    try:
        os.unlink(os.path.join(dbpath, '.started'))
    except OSError:
        pass
    cmd.append('--dbpath=%s' % dbpath)
    if env.get('MULTIFARM'):
        cmd.append('--dbextra=%s' % os.path.join(env['GDK_DBFARM'], TSTPREF + '_transient'))
        shutil.rmtree(os.path.join(env['GDK_DBFARM'], TSTPREF + '_transient'),
                      ignore_errors = True)
        os.makedirs(os.path.join(env['GDK_DBFARM'], TSTPREF + '_transient'))
    elif env.get('TRANS_INMEM'):
        cmd.append('--dbextra=in-memory')
    if procdebug:
        print('GetBitsAndModsAndThreads: starting process "%s" (inpipe, outpipe, errpipe)\n' % '" "'.join(cmd))
    setpgrp = True
    proc = process.Popen(cmd, stdin=process.PIPE, stdout=process.PIPE,
                         stderr=process.PIPE, text=True)
    proc.killed = False
    proc.onechild = True
    t = Timer(float(par['TIMEOUT']), killProc, args = [proc, proc.stderr, cmd])
    qOut = qErr = None
    try:
        t.start()
        while True:
            proc.poll()
            if proc.returncode is not None:
                break
            if os.path.exists(os.path.join(dbpath, '.started')):
                break
            time.sleep(0.001)
        if proc.returncode is None:
            cmd = splitcommand(env['exe']['MAL_Client'][1])
            if procdebug:
                print('GetBitsAndModsAndThreads: starting process "%s" (inpipe, outpipe, errpipe)\n' % '" "'.join(cmd))
            clnt = process.Popen(cmd, stdin=process.PIPE, stdout=process.PIPE,
                                 stderr=process.PIPE, text=True)
            input = '''\
                c := mdb.modules();
                modsid := algebra.unique(c,nil:bat);
                mods := algebra.projection(modsid,c);
                s := "\\nModules: ";
                sep := "";
                barrier (h:oid,t:str) := iterator.new(mods);
                        s := s + sep;
                        s := s + "\'";
                        s := s + t;
                        s := s + "\'";
                        sep := ",";
                redo (h:oid,t:str) := iterator.next(mods);
                exit h;
                s := s + "\\n";
                io.printf(s);
            '''
            ##module("NoModule");
            qOut, qErr = clnt.communicate(input=input)
            proc.terminate()
            sOut = proc.stdout.read()
            sErr = proc.stderr.read()
            proc.wait()
            qOut = sOut + qOut
            qErr = sErr + qErr
    finally:
        t.cancel()
        if proc.returncode is None:
            killProc(proc, proc.stderr, cmd)
            proc.wait()
        if procdebug:
            print('GetBitsAndModsAndThreads: process exited "%s" (%s)\n' % ('" "'.join(cmd), proc.returncode))
    env['TST_MODS'] = []
    env['TST_BITS'] = ""
    env['TST_INT128'] = ""
    env['TST_SINGLE'] = ""
    env['TST_THREADS'] = ""
    env['TST_ARCH'] = ""
    if qOut:
        tbos = re.compile("^# Compiled for (?P<arch>[^-]+).*/(?P<bits>[63][42]bit)(?P<int128> with 128bit integers|)", re.MULTILINE)
        tt = re.compile("^# Serving database .*, using ([0-9]+) threads?", re.MULTILINE)
        tm = re.compile("^Modules: (.+)$", re.MULTILINE)
        for l in qOut.split('\n'):
            obs = tbos.match(l)
            if obs is not None:
                env['TST_BITS'] = obs.group('bits')
                os.environ['TST_BITS'] = env['TST_BITS']
                if obs.group('int128') == " with 128bit integers":
                    env['TST_INT128'] = "int128"
                    os.environ['TST_INT128'] = env['TST_INT128']
                arch = obs.group('arch')
                if arch == 'amd64':
                    arch = 'x86_64' # normalize name
                env['TST_ARCH'] = arch
            t = tt.match(l)
            if t:
                if t.group(1) == "1":
                    env['TST_SINGLE'] = "single"
                    os.environ['TST_SINGLE'] = env['TST_SINGLE']
                env['TST_THREADS'] = t.group(1)
            m = tm.match(l)
            if m:
                env['TST_MODS'] = eval(m.group(1))
        if not env['TST_BITS']:
            ErrMsg("Checking for Bits failed!")
        if not env['TST_MODS']:
            ErrMsg("Checking for Modules failed!")
        if not env['TST_BITS'] or not env['TST_MODS']:
            STDERR.write(' '.join(cmd) + "\n\n")
            STDERR.write(qOut)
            STDERR.write("\n")
            STDERR.write(qErr)
            STDERR.write("\n")
            STDERR.flush()
            rtrn = 1
    else:
        rtrn = 1
        ErrMsg("No output from mserver5 when checking for Bits, Modules & Threads!?")
        if qErr:
            STDERR.write(' '.join(cmd) + "\n\n")
            STDERR.write(qErr)
            STDERR.write("\n")
            STDERR.flush()
    os.environ['TST_MODS'] = str(env['TST_MODS'])
    return rtrn
### GetBitsAndModsAndThreads(env) #

def CheckMods(env, TST, SERVER) :
    missing = []
    reqmodules = TST.get('reqmodules', [])
    for m in reqmodules:
        if m not in env['TST_MODS']:
            missing.append(m)
    if SERVER == "SQL":
        sql_mods = ["sql"]
        for m in sql_mods:
            if m not in env['TST_MODS']:
                missing.append(m)
    return missing
### CheckMods(env, TST, SERVER, CALL) #

def CheckTests(env, TST, oktests):
    missing = []
    reqtests = TST.get('reqtests', [])
    if env.get('NOCLEAN'):
        # we didn't clean up from a previous run, assume tests were done
        return missing
    for test in reqtests:
        if test not in oktests:
            missing.append(test)
    return missing
### CheckTests(env, TST, oktests) #

relcond = {
    # upgrade testing conditionals:
    # key is condition, value is tuple with file name and part of message
    'PREVREL': ('prevrel.zip', 'previous'),
    'PREVHGEREL': ('prevhgerel.zip', 'previous hugeint'),
    'PREVCHAINREL': ('prevchainrel.zip', 'previous chained'),
    'PREVHGECHAINREL': ('prevhgechainrel.zip', 'previous hugeint chained'),
    'PREVRELEMPTY': ('prevrelempty.zip', 'previous empty'),
    'PREVHGERELEMPTY': ('prevhgerelempty.zip', 'previous hugeint empty'),
    'PREVCHAINRELEMPTY': ('prevchainrelempty.zip', 'previous chained empty'),
    'PREVHGECHAINRELEMPTY': ('prevhgechainrelempty.zip',
                             'previous hugeint chained empty'),
    'LASTREL': ('lastrel.zip', 'last'),
    'LASTHGEREL': ('lasthgerel.zip', 'last hugeint'),
    'LASTCHAINREL': ('lastchainrel.zip', 'last chained'),
    'LASTHGECHAINREL': ('lasthgechainrel.zip', 'last hugeint chained'),
    'LASTRELEMPTY': ('lastrelempty.zip', 'last empty'),
    'LASTHGERELEMPTY': ('lasthgerelempty.zip', 'last hugeint empty'),
    'LASTCHAINRELEMPTY': ('lastchainrelempty.zip', 'last chained empty'),
    'LASTHGECHAINRELEMPTY': ('lasthgechainrelempty.zip',
                             'last hugeint chained empty'),
}

def print_err_code(err_code):
    # TODO add all err codes
    lookup = {
            F_ERROR: lambda x: prred('ERROR'),
            F_SKIP: lambda x: prpurple('SKIP'),
            F_SOCK: lambda x: prpurple('SOCK')
            }
    lookup.get(err_code, lambda _: prgreen('OK'))(err_code)

def RunTest(env, test, oktests, pSrvr):
    global setpgrp
    exit_code = F_SKIP
    TX = 0
    TSTDB = env['TSTDB']
    TSTDIR  = env['TSTDIR']
    TSTSRCDIR = env['TSTSRCDIR']
    RELSRCDIR = env['RELSRCDIR']
    TSTTRGDIR = env['TSTTRGDIR']
    reason = None               # reason for skipping (if any)
    links = []                  # symlinks we make
    threads = None              # set if we override number of threads

    EXT = test.get('ext')
    CALL = test.get('call')
    SERVER = test.get('server')
    TST = test.get('test_name')
    is_reqtest = test.get('is_reqtest', False)
    has_reqtests = len(test.get('reqtests', [])) > 0

    # are there missing modules?
    MissingMods = CheckMods(env, test, SERVER)
    # are all reqtests run before this one?
    MissingTests = CheckTests(env, test, oktests)
    nomito = test.get('nomito', False)
    user = None
    passwd = None
    BUSY_PORTS = env.get('BUSY_PORTS', [])
    test_counter = env.get('test_counter', 1)

    # print progress
    progress(test_counter, env.get('test_count'), os.path.join(TSTDIR, TST + EXT))

    # change to test target directory
    os.chdir(TSTTRGDIR)

    COND = test.get('cond')
    if COND:
        for cond in COND.split('&'):
            if cond.startswith('!'):
                negate = True
                cond = cond[1:]
            else:
                negate = False
            if cond in relcond:
                if not os.path.exists(os.path.join(env['GDK_DBFARM'], relcond[cond][0])):
                    reason = "as %s release database is not available" % relcond[cond][1]
                    break
            elif cond.startswith('THREADS='):
                if negate:
                    reason = "impossible combination of THREADS= and negation"
                    break
                elif env['GDK_NR_THREADS'] == '0' or \
                   int(env['TST_THREADS']) >= int(cond[8:]):
                    threads = cond[8:]
                elif env['TST_THREADS'] != cond[8:]:
                    reason = "as number of threads is wrong"
                    break
            elif cond.startswith('THREADS<='):
                if (int(env['TST_THREADS']) <= int(cond[9:])) == negate:
                    reason = "as number of threads is wrong"
                    break
            elif cond.startswith('THREADS>='):
                if (int(env['TST_THREADS']) >= int(cond[9:])) == negate:
                    reason = "as number of threads is wrong"
                    break
            elif cond.startswith('USER='):
                if negate:
                    reason = "impossible combination of USER= and negation"
                    break
                user = cond[5:]
            elif cond.startswith('PASSWD='):
                if negate:
                    reason = "impossible combination of PASSWD= and negation"
                    break
                passwd = cond[7:]
            elif cond not in CONDITIONALS:
                reason = "as conditional '%s' is unknown." % cond
                break
            elif (not CONDITIONALS[cond]) != negate:
                if negate:
                    reason = "as conditional '%s' holds." % cond
                else:
                    reason = "as conditional '%s' does not hold." % cond
                break
    if reason:
        pass
    elif MissingTests:
        reason = "as required test%s '%s' failed." % (len(MissingTests) != 1 and 's' or '', "', '".join(MissingTests))
    elif EXT == ".malC" and  not env['exe']['MAL_Client'][0]:
        reason = "as %s is not available." % env['MALCLIENT'].split(None, 1)[0]
    elif EXT == ".sql" and  not env['exe']['SQL_Client'][0]:
        reason = "as %s is not available." % env['SQLCLIENT'].split(None, 1)[0]
    elif EXT == ".sql" and  not env['exe']['SQL_Dump'][0]:
        reason = "as %s is not available." % env['SQLDUMP'].split(None, 1)[0]
    elif EXT == ".test" and not CONDITIONALS['HAVE_PYMONETDB']:
        reason = "as pymonetdb is not available."
    elif EXT == ".maltest" and not CONDITIONALS['HAVE_PYMONETDB']:
        reason = "as pymonetdb is not available."
    elif SERVER in ["MAL", "SQL"] and not env['exe']['mserver5'][0]:
        reason = "as %s is not available." % env['MSERVER'].split(None, 1)[0]
    elif EXT == ".malS" and not env['exe']['mserver5'][0]:
        reason = "as %s is not available." % env['MSERVER'].split(None, 1)[0]
    elif CALL == "python"  and  not env['exe']['python'][0]:
        reason = "as python is not available."
        #TODO:
        #elif [ "$EXT" = "java"  -a  ! "`type -path java`" ] ; then
    elif MissingMods:
        reason = "as modules '%s` are missing." % str(MissingMods)
    elif CALL == "malXp":
        reason = "as multiple MAL clients in parallel are currently not supported by %s." % THISFILE
    elif CALL == "sqlXp":
        reason = "as multiple SQL clients in parallel are currently not supported by %s." % THISFILE
    elif SERVER in ["MAL", "SQL"] and "MAPI" in BUSY_PORTS:
        reason = "as MAPIPORT=%s is not available." % env['MAPIPORT']
    else:
        #test_rgx = re.compile("^"+TST+"((_[sp][0-9][0-9])?\..*)?$", re.MULTILINE)
        test_rgx = re.compile("^"+TST+"((_[sp][0-9][0-9])?\.(?!stable).*)?$", re.MULTILINE)
        for f in listdir(TSTSRCDIR):
            if test_rgx.match(f):
                try:
                    SymlinkOrCopy(os.path.join(TSTSRCDIR, f), f)
                    links.append(os.path.join(TSTTRGDIR, f))
                except IOError as err:
                    if not env.get('NOCLEAN'):
                        ErrMsg("SymlinkOrCopy('%s','%s') in '%s' failed with #%d: '%s'."
                               % (os.path.join(dir_, f), f, os.getcwd(), err.errno, err.strerror))
                except OSError:
                    if not env.get('NOCLEAN'):
                        raise
        # Check for available sockets and block them until we're ready to run the actual test
        if pSrvr is None:
            MAPIsockets, reason = CheckSocket2(env, "MAPI")   #, SrvrErr)
            if MAPIsockets is None:
                reason = 'as ' + reason
                return TX,F_SKIP,reason,links
        else:
            MAPIsockets = None

        if test.get('is_src_link', False) and not os.path.isfile(TST + EXT):
            with openutf8(test.get('test_path') + test.get('tail'), 'r') as f:
                TSTSRC = expandvars(f.readline().strip(), env)
            if os.path.isfile(TSTSRC):
                try:
                    SymlinkOrCopy(TSTSRC, TST + EXT)
                    links.append(TST + EXT)
                except IOError as err:
                    ErrMsg("SymlinkOrCopy('%s','%s') in '%s' failed with #%d: '%s'."
                           % (TSTSRC, TST + EXT, os.getcwd(), err.errno, err.strerror))
            else:
                reason = "as source file '%s` is missing." % TSTSRC
                if MAPIsockets is not None:
                    # Release reserved sockets before bailing out
                    MAPIsockets[0].close()
                    MAPIsockets[1].close()
                return TX,F_SKIP,reason,links
        elif test.get('is_input', False) and not os.path.isfile(TST+EXT):
            with openutf8(os.path.join(TSTTRGDIR, TST + EXT), 'w') as fout:
                with openutf8(test.get('test_path') + test.get('tail'), 'r') as f:
                    for l in f:
                        fout.write(expandvars(l, env))
        else:
            if not os.path.isfile(TST+EXT):
                SymlinkOrCopy(test.get('test_path') + EXT, TST + EXT)
                links.append(os.path.join(TSTTRGDIR, TST + EXT))

        TIMEOUT = int(par['TIMEOUT'] * test.get('timeout', 1))
        CTIMEOUT = 0
        if   CALL in ["other", "python", "ruby"]:
            if TIMEOUT > 0:
                CTIMEOUT = CTIMEOUT + min(TIMEOUT, par['TIMEOUT'])
        elif CALL == "sqlXs":
            test = re.compile("^"+TST+"_s[0-9][0-9]"+EXT+"$", re.MULTILINE)
            d = listdir(os.getcwd())
            for f in d:
                if test.match(f):
                    CTIMEOUT = CTIMEOUT + TIMEOUT
        elif CALL in ["mal", "sql"]:
            CTIMEOUT = CTIMEOUT + TIMEOUT
        if  CTIMEOUT < TIMEOUT:
            CTIMEOUT = TIMEOUT
        STIMEOUT = CTIMEOUT
        if  SERVER in ["MAL", "SQL"] and TIMEOUT > 0:
            STIMEOUT = STIMEOUT + TIMEOUT + min(TIMEOUT, par['TIMEOUT'])


        TestOutFile = TST+".test.out"
        TestErrFile = TST+".test.err"

        t0 = time.time()
        if CALL == 'sqltest' or CALL == 'maltest':
            # TODO make TestOutFile optional
            exit_code, reason = RunSQLLogicTest(env, (TST + EXT), TestOutFile, TestErrFile, is_reqtest=is_reqtest, has_reqtests=has_reqtests, lsql= CALL == 'sqltest')
        else:
         tres = DoIt(env, SERVER, CALL, TST, EXT, TestOutFile, TestErrFile, STIMEOUT, CTIMEOUT, TIMEOUT, MAPIsockets, nomito, threads, user, passwd, COND, pSrvr)
         exit_code = transform_str_return_code(tres)

        t1 = time.time()
        TX = t1 - t0

        if exit_code > F_OK:
            print()
            print('========================================')
            prred('ERROR: ')
            print(os.path.join(TSTDIR, TST + EXT))
            print('========================================')
            with openutf8(TestErrFile, 'r') as f:
                print(f.read())
            print()

    env['test_counter'] = test_counter + 1
    return TX, exit_code, reason, links
### RunTest(env, TST, BUSY_PORTS, COND, oktests) #

def CheckPort(port) :
    # Since 'localhost' and $HOST (i.e., `hostname`) are usually
    # different interfaces, we check both, unless $HOST (`hostname`)
    # appears to be merely an alias for 'localhost'.  That is, if the
    # hostname works, we prefer it over localhost, but don't require it,
    # such as e.g. on interwebless laptops.
    busy = 0
    Serrno = 0
    Serrstr = ""
    S0 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    S1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    S0.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    S1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    host = os.environ['HOST']
    try:
        S1.bind((host,port))
    except socket.error as err:
        Serrno = err.errno
        Serrstr = err.strerror
        S1.close();
        host = 'localhost'
        try:
            S0.bind((host,port))
        except socket.error as err:
            Serrno = err.errno
            Serrstr = err.strerror
            S0.close()
            busy = 1

    return busy, host, Serrno, Serrstr, (S0, S1)
### CheckPort(port) #

def randomPort(l,h) :
    repeat = randomPortRepeat
    port = 0
    rpt = 0
    ports = []
    while rpt < repeat:
        port = random.randrange(l,h,1)
        ports.append(port)
        busy, host, Serrno, Serrstr, S = CheckPort(port)
        S[0].close()
        S[1].close()
        if busy:
            rpt = rpt + 1
            port = 0
        else:
            break
    return (port,host)
### randomPort(l,h) #

def CheckSocket2(env,SERVER) :  #,SrvrErr) :
    port = int(env[SERVER+'PORT'])
    newport = port
    busy, host, Serrno, Serrstr, S = CheckPort(port)
    if busy:
        S[0].close()
        S[1].close()
        Smsg = """
! Socket-Check failed for %sserver on <%s:%d> with #%d; '%s' !
""" % (SERVER, host, port, Serrno, Serrstr)
        newport = eval(dft[SERVER+'PORT'])
        if newport == 0:
            S[0].close()
            S[1].close()
            Smsg = Smsg + """
! Socket-Check failed for %sserver on <%s> !
! Giving up after %d attepts !
""" % (SERVER, host, randomPortRepeat)
            return None, Smsg

        env[SERVER+'PORT'] = newport
        os.environ[SERVER+'PORT'] = env[SERVER+'PORT']
        op = 'port=%d' % port
        np = 'port=%s' % env[SERVER+'PORT']
        env['exe']['mserver5']      = env['exe']['mserver5'][0]      , env['exe']['mserver5'][1].replace(op, np)
        env['exe']['MAL_Client']    = env['exe']['MAL_Client'][0]    , env['exe']['MAL_Client'][1].replace(op, np)
        env['exe']['SQL_Client']    = env['exe']['SQL_Client'][0]    , env['exe']['SQL_Client'][1].replace(op, np)
        env['exe']['SQL_Dump']      = env['exe']['SQL_Dump'][0]      , env['exe']['SQL_Dump'][1].replace(op, np)
        os.environ['MSERVER']       = os.environ['MSERVER'].replace(op, np)
        os.environ['MAL_CLIENT']    = os.environ['MAL_CLIENT'].replace(op, np)
        os.environ['SQL_CLIENT']    = os.environ['SQL_CLIENT'].replace(op, np)
        os.environ['SQL_DUMP']      = os.environ['SQL_DUMP'].replace(op, np)
        Smsg = Smsg + """
! Using new %sPORT=%s !
""" % (SERVER, env[SERVER+'PORT'])
#        STDERR.write(Smsg)
#        STDERR.flush()
#        SrvrErr.write(Smsg)
#        SrvrErr.flush()

    return S, None
### CheckSocket2(env,SERVER)    #,SrvrErr) #

def CheckSocket3(env,SERVER,ErrFileName) :
    res = F_OK
    port = int(env[SERVER+'PORT'])
    busy, host, Serrno, Serrstr, S = CheckPort(port)
    S[0].close()
    S[1].close()
    if busy:
        res = F_SOCK
        Smsg = """
! Socket-Check failed for %sserver on <%s:%d> with #%d; '%s' !
! %sPORT was not properly released by mserver5 !
""" % (SERVER, host, port, Serrno, Serrstr, SERVER)
        STDERR.write(Smsg)
        STDERR.flush()
        ErrFile = openutf8(ErrFileName, 'a')
        ErrFile.write(Smsg)
        ErrFile.flush()
        ErrFile.close()
    return res
### CheckSocket3(env,SERVER,ErrFileName) #

def prompt() :
    return time.strftime('%H:%M:%S> ',time.localtime(time.time()))
### prompt() #

def Prompt(cmd) :
    if type(cmd) is type([]):
        cmd = '" "'.join(cmd)
    prmpt = time.strftime('\n# %H:%M:%S >  ',time.localtime(time.time()))
    return '%s%s"%s"%s\n\n' % (prmpt, prmpt, cmd, prmpt)
### Prompt(cmd) #

def progress(count, total, test):
    perc = round((count/total) * 100) if total and count else 0
    print('\r', ' '*(ttywidth or 100), end='', sep='')
    print('\r','[{}/{}] ({}%)    {}'.format(count, total, perc, test), end='', sep='', flush=True)

def getkids():
    # return a dictionary with process IDs as key and a list of child
    # processes as value
    p = process.Popen(['ps', '-lu', os.getenv('USER')],
                      stdout=process.PIPE, stderr=process.PIPE,
                      text=True)
    out, err = p.communicate()
    if err:
        return {}
    lines = out.split('\n')
    line0 = lines[0].split()
    del lines[0]
    del lines[-1]
    pidcol = ppidcol = None
    for i in range(len(line0)):
        if line0[i] == 'PID':
            pidcol = i
        elif line0[i] == 'PPID':
            ppidcol = i
    if pidcol is None or ppidcol is None:
        return {}
    procs = {}
    for line in lines:
        line = line.split()
        try:
            pid = int(line[pidcol])
            ppid = int(line[ppidcol])
        except (ValueError, IndexError):
            continue
        if ppid not in procs:
            procs[ppid] = []
        procs[ppid].append(pid)
    return procs

def killchildren(pid, procs = None):
    # not called on Windows
    # kill the specified process ID and all its children
    if procs is None:
        try:
            os.killpg(pid, signal.SIGKILL)
            return
        except AttributeError:
            try:
                os.kill(-pid, signal.SIGKILL)
                return
            except OSError:
                pass
        except OSError:
            pass
        procs = getkids()
    for kid in procs.get(pid, []):
        killchildren(kid, procs)
    if procdebug:
        print('killing process %d' % pid)
    try:
        os.kill(pid, signal.SIGKILL)
    except OSError:
        if procdebug:
            print('killing process %d failed' % pid)

def reallyKill(proc):
    # not called on Windows
    killchildren(proc.pid, getkids())

def killProc(proc, outfile = None, cmd = None):
    if type(cmd) is type([]):
        cmd = ' '.join(cmd)
    if procdebug:
        print('timeout for process %d (%s)' % (proc.pid, cmd))
    if outfile is not None and cmd is not None:
        try:
            outfile.write('\n!Mtimeout: Timeout: %s\n' % cmd)
        except (ValueError, IOError):
            print('cannot write timeout message ' + cmd)
    if os.name == "nt":
        sym = ''
        if os.path.exists(r'c:\Program Files\Debugging Tools for Windows (x64)\cdb.exe'):
            cdb = r'c:\Program Files\Debugging Tools for Windows (x64)\cdb.exe'
            if os.path.exists(r'c:\Symbols'):
                sym = r'c:\Symbols;'
        elif os.path.exists(r'c:\Program Files\Debugging Tools for Windows (x86)\cdb.exe'):
            cdb = r'c:\Program Files\Debugging Tools for Windows (x86)\cdb.exe'
            if os.path.exists('c:\WINDOWS\Symbols'):
                sym = r'c:\WINDOWS\Symbols;'
        else:
            cdb = None
        if cdb:
            p = process.Popen([cdb, '-pv', '-p', str(proc.pid),
                               '-y', '%scache*;srv*http://msdl.microsoft.com/download/symbols' % sym, '-lines', '-c', '~*kP;!locks;q'],
                              stdout=process.PIPE, text=True)
            out, err = p.communicate()
        else:
            out = ''
    else:
        try:
            p = process.Popen(['pstack', str(proc.pid)], stdout=process.PIPE,
                              text=True)
            try:
                # pstack (gdb) sometimes hangs when trying to get the
                # stack trace: kill it mercilessly if it does
                t = Timer(60, reallyKill, args = [p])
                t.start()
            except AttributeError:
                t = None
            out, err = p.communicate()
            if t is not None:
                t.cancel()
        except:
            out = ''
    if outfile is not None and out:
        try:
            outfile.write('\n%s\n' % out)
        except (ValueError, IOError):
            print('cannot write stack trace')
            print(out)
    proc.killed = True
    if proc.onechild:
        if procdebug:
            print('killProc: calling proc.kill() on PID %d' % proc.pid)
        proc.kill()
    elif os.name == 'nt':
        if procdebug:
            print('killProc: starting process "taskkill" "/F" "/T" "/PID" "%s"\n' % str(proc.pid))
        p = process.Popen(['taskkill','/F','/T','/PID',str(proc.pid)],
                          stdout=process.PIPE, stderr=process.PIPE,
                          text=True)
        out, err = p.communicate()
        if procdebug:
            print('killProc: process exited "taskkill" "/F" "/T" "/PID" "%s" (%s)\n' % (str(proc.pid), proc.returncode))
        proc.kill()
    else:
        killchildren(proc.pid)

class ServerClass:
    def __init__(self, cmd, outfile, errfile, timeout, pollfile, port):
        self.proc = None
        self.timer = None
        self.outfile = outfile
        self.errfile = errfile
        self.code = None
        self.started = False
        self.cmd = cmd
        self.timeout = timeout
        self.pollfile = pollfile
        self.port = port

    def poll(self):
        return self.proc.poll()

    def terminate(self):
        self.timer.cancel()
        t = Timer(60, killProc, args = [self.proc, self.errfile, self.cmd])
        t.start()
        if os.name == 'nt':
            self.proc.send_signal(signal.CTRL_BREAK_EVENT)
        else:
            self.proc.terminate()
        self.proc.wait()
        t.cancel()
        self.code = returnCode(self.proc, self.errfile)
        self.outfile.close()
        self.errfile.close()

    def LaunchIt(self):
        global setpgrp

        self.outfile.write(Prompt(self.cmd))
        self.outfile.flush()
        self.errfile.write(Prompt(self.cmd))
        self.errfile.flush()

        if procdebug:
            print('LaunchIt: starting process "%s" (inpipe)\n' % '" "'.join(self.cmd))
        setpgrp = True
        if self.pollfile:
            try:
                os.unlink(self.pollfile)
            except OSError:
                pass
        if os.name == "nt":
            proc = process.Popen(self.cmd, stdin=open(os.devnull), stdout=self.outfile,
                                 stderr=self.errfile, text=True,
                                 creationflags=process.CREATE_NEW_PROCESS_GROUP)
        else:
            proc = process.Popen(self.cmd, stdin=open(os.devnull), stdout=self.outfile,
                                 stderr=self.errfile, text=True)
        # maybe buffer output as it comes to avoid deadlock
        if self.outfile == process.PIPE:
            proc.stdout = process._BufferedPipe(proc.stdout)
        if self.errfile == process.PIPE:
            proc.stderr = process._BufferedPipe(proc.stderr)
        proc.killed = False
        proc.onechild = True
        t = Timer(self.timeout, killProc, args = [proc, self.errfile, self.cmd])
        t.start()
        self.proc = proc
        self.timer = t

        port = self.port
        if self.pollfile:
            while True:
                proc.poll()
                if proc.returncode is not None:
                    # exited
                    proc.wait()
                    t.cancel()
                    return
                if os.path.exists(self.pollfile):
                    break
                time.sleep(0.001)
        elif port is not None:
            while True:
                proc.poll()
                if proc.returncode is not None:
                    # exited
                    proc.wait()
                    t.cancel()
                    return
                if mapi_ping(port):
                    break
                time.sleep(0.1)
            port = None         # don't try again
        if port is not None and not mapi_ping(port):
            # check whether we can connect
            if os.name == "nt":
                proc.send_signal(signal.CTRL_BREAK_EVENT)
            else:
                proc.terminate()
            proc.wait()
            t.cancel()
            return
        self.started = True
#ServerClass(cmd, outfile, errfile, timeout, pollfile, port)


def create_mserver5(dbpath, timeout=0, env={}, outfile=None, errfile=None, options=[]):
    port = int(env.get('MAPIPORT', randomPort(30000, 39999)))
    pollfile = os.path.join(dbpath, '.started')
    outfile = openutf8(outfile, 'a') if outfile else sys.stdout
    errfile = openutf8(errfile, 'a') if errfile else sys.stderr
    cmd = splitcommand(env['exe']['mserver5'][1]) + ['--dbpath=%s' % dbpath] + options
    TSTPREF = env.get('TSTPREF')
    if env.get('MULTIFARM'):
        cmd.append('--dbextra=%s' % os.path.join(env['GDK_DBFARM'], TSTPREF + '_transient'))
        shutil.rmtree(os.path.join(env['GDK_DBFARM'], TSTPREF + '_transient'),
                      ignore_errors = True)
        os.makedirs(os.path.join(env['GDK_DBFARM'], TSTPREF + '_transient'))
    elif env.get('TRANS_INMEM'):
        cmd.append('--dbextra=in-memory')
    return ServerClass(cmd,
                outfile,
                errfile,
                timeout,
                pollfile,
                port)


def RunIt(cmd, onechild, TestIn, TestOut, TestErr, TimeOut) :
    global setpgrp
    if type(TestIn) is type(''):
        TestInput = TestIn
        TestIn = process.PIPE
    else:
        TestInput = None
    TestOut.write(Prompt(cmd))
    TestOut.flush()
    TestErr.write(Prompt(cmd))
    TestErr.flush()
    if procdebug:
        print('RunIt: starting process "%s"\n' % '" "'.join(cmd))
    setpgrp = True
    proc = process.Popen(cmd, stdin=TestIn, stdout=TestOut,
                         stderr=TestErr, text=True)
    proc.killed = False
    proc.onechild = onechild
    t = Timer(TimeOut, killProc, args = [proc, TestErr, cmd])
    try:
        t.start()
        # since both stdout and stderr are redirected to files,
        # communicate will not return any useful data
        proc.communicate(input = TestInput)
        t.cancel()
        if procdebug:
            print('RunIt: process exited "%s" (%s)\n' % ('" "'.join(cmd), proc.returncode))
    except KeyboardInterrupt:
        t.cancel()
        killProc(proc, TestErr, cmd)
        if procdebug:
            print('RunIt: process killed "%s"\n' % '" "'.join(cmd))
        raise
    rc = returnCode(proc, TestErr)
    if rc == 'interrupt':
        raise KeyboardInterrupt
    return rc
### RunIt(cmd, onechild, TestIn, TestOut, TestErr) #

def Log() :
    time.strftime('%H:%M:%S> ',time.localtime(time.time()))
### Log() #

def mapi_ping(port) :
    retry = 0
    wait = 1
    host = 'localhost'
    while retry < 3:
        retry += 1
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((host, port))
            flag = sock.recv(2)
            unpacked = struct.unpack( '<H', flag )[0]  # little endian short
            len = ( unpacked >> 1 )     # get length
            data = sock.recv(len)
            # we don't send
            return True
        except socket.error:
            pass
        time.sleep(wait)
    return False
### mapi_ping() #

def RunSQLLogicTest(env, Test, TestOut, TestErr, is_reqtest=False, has_reqtests=False, lsql=True) -> (int, str):
    """
    Run SQLLogic test
    returns:
       (exit_code, msg)
    """
    import MonetDBtesting.sqllogictest as sqllogictest
    exit_code = None
    msg = None
    with openutf8(TestErr, 'w') as f:
        sql = sqllogictest.SQLLogic(out=f)
        if TestOut:
            sql.res = openutf8(TestOut, 'w')
        try:
            sql.connect(hostname='localhost',
                        port=int(env['MAPIPORT']),
                        database=env['TSTDB'], language='sql' if lsql else 'mal')
        except Exception as e:
            exit_code = F_SOCK
            msg = "Connection refused"
            print(e, file=f)
        else:
            # if not required by any other test clean up
            if not is_reqtest:
                sql.drop()
            try:
                sql.parse(Test)
            except sqllogictest.SQLLogicSyntaxError as e:
                print(e, file=f)
                exit_code = F_SKIP
                msg = 'sqllogic syntax error'
            except BrokenPipeError as e:
                # server timeout
                print(e, file=f)
                exit_code = F_SOCK
                msg = "Broken pipe"
            sql.close()
            if sql.res:
                sql.res.close()
    is_dirty = os.path.getsize(TestErr) > 0
    # clean up if all okay
    if not is_dirty:
        os.remove(TestErr)
    if is_dirty and exit_code is None:
        exit_code = F_ERROR
    return exit_code or F_OK, msg

def DoIt(env, SERVER, CALL, TST, EXT, TestOutFile, TestErrFile, STIMEOUT, CTIMEOUT, TIMEOUT, MAPIsockets, nomito, threads, user, passwd, COND, PSRVR) :

    TSTDB = env['TSTDB']
    exe = env['exe']

    if MAPIsockets is not None:
        # Release reserved sockets and run the actual test
        MAPIsockets[0].close()
        MAPIsockets[1].close()

    returncode = None
    pSrvr = PSRVR
    try:
        if SERVER in ["MAL", "SQL"]:
            SrvrOutFile = TST+".server.out"
            SrvrErrFile = TST+".server.err"
            SrvrOut = openutf8(SrvrOutFile,"w")
            SrvrErr = openutf8(SrvrErrFile,"w")
            ClntOutFile = TST+".client.out"
            ClntErrFile = TST+".client.err"
            ClntOut = openutf8(ClntOutFile,"w")
            ClntErr = openutf8(ClntErrFile,"w")

            Srvr = splitcommand(exe['mserver5'][1])
            if nomito:
                try:
                    Srvr.remove('--forcemito')
                except ValueError:
                    pass
            if threads is not None:
                for i in range(len(Srvr)):
                    if Srvr[i].startswith('gdk_nr_threads='):
                        Srvr[i] = 'gdk_nr_threads=%s' % threads
                        break
            dbpath = os.path.join(env['GDK_DBFARM'], TSTDB)
            Srvr.append('--dbpath=%s' % dbpath)
            if env.get('MULTIFARM'):
                Srvr.append('--dbextra=%s' % os.path.join(env['GDK_DBFARM'], TSTDB + '_transient'))
                shutil.rmtree(os.path.join(env['GDK_DBFARM'], TSTDB + '_transient'),
                              ignore_errors = True)
                os.makedirs(os.path.join(env['GDK_DBFARM'], TSTDB + '_transient'))
            elif env.get('TRANS_INMEM'):
                Srvr.append('--dbextra=in-memory')
            if os.path.isfile(TST + '.options5'):
                Srvr.extend(openutf8(TST + '.options5').read().split())
            lang=""

            if SERVER == "MAL":
                lang="mal"
            if SERVER == "SQL":
                lang="sql"

            # enable r integration in server
            if ((COND != None and "HAVE_LIBR" in COND)) and CONDITIONALS['HAVE_LIBR'] and CONDITIONALS['NOT_WIN32']:
                Srvr.extend(['--set', 'embedded_r=yes'])

            savepath = None
            savepypath = os.environ.get('PYTHONPATH')
            savepyhome = os.environ.get('PYTHONHOME')
            if (COND != None and "HAVE_LIBPY3" in COND) and CONDITIONALS['HAVE_LIBPY3']:
                # enable Python 3 integration in server
                if winreg is not None:
                    if env['TST_BITS'] == '32bit':
                        if sys.maxsize > 2**32:
                            regkey = r'SOFTWARE\Wow6432Node\Python\PythonCore\3.@PY3VER@-32\InstallPath'
                        else:
                            regkey = r'SOFTWARE\Python\PythonCore\3.@PY3VER@-32\InstallPath'
                    else:
                        regkey = r'SOFTWARE\Python\PythonCore\3.@PY3VER@\InstallPath'
                    try:
                        with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, regkey) as key:
                            instpath = winreg.QueryValue(key, None)
                            os.environ['PYTHONHOME'] = instpath
                            os.environ['PYTHONPATH'] = instpath + 'Lib'
                            savepath = os.environ['PATH']
                            os.environ['PATH'] = instpath.rstrip('\\') + os.pathsep + savepath
                    except WindowsError:
                        pass
                Srvr.extend(['--set', 'embedded_py=3'])

            # enable C integration in server
            Srvr.extend(['--set', 'embedded_c=true'])

            if PSRVR is None:
                # TODO
                #def create_mserver5(dbpath, timeout=0, env={}, outfile=None, errfile=None, options=[]):
                if env.get('MULTIFARM'):
                    Srvr.append('--dbextra=%s' % os.path.join(env['GDK_DBFARM'], TSTPREF + '_transient'))
                    shutil.rmtree(os.path.join(env['GDK_DBFARM'], TSTPREF + '_transient'),
                                  ignore_errors = True)
                    os.makedirs(os.path.join(env['GDK_DBFARM'], TSTPREF + '_transient'))
                elif env.get('TRANS_INMEM'):
                    Srvr.append('--dbextra=in-memory')
                pSrvr = ServerClass(Srvr, SrvrOut, SrvrErr, TIMEOUT, os.path.join(dbpath, '.started'), int(env['MAPIPORT']))
                pSrvr.LaunchIt()
            if savepath is not None:
                os.environ['PATH'] = savepath
                if savepypath:
                    os.environ['PYTHONPATH'] = savepypath
                else:
                    del os.environ['PYTHONPATH']
                if savepyhome:
                    os.environ['PYTHONHOME'] = savepyhome
                else:
                    del os.environ['PYTHONHOME']
        else:
            ClntOut = openutf8(TestOutFile, 'a')
            ClntErr = openutf8(TestErrFile, 'a')

        if SERVER not in ["MAL", "SQL"] or pSrvr.started:
            if   CALL == "other":
                cmd = [os.path.join(".", TST + EXT), TST]
                returncode = RunIt(cmd, False, "", ClntOut, ClntErr, CTIMEOUT)
            elif CALL == "python":
                cmd = splitcommand(exe['python'][1]) + [TST + EXT, TST]
                returncode = RunIt(cmd, False, "", ClntOut, ClntErr, CTIMEOUT)
            elif CALL in ["mal", "malXs"]:
                TSTs = []
                if CALL == "mal":
                    X=""
                else:
                    X="_s[0-9][0-9]"
                test = re.compile("^"+TST+X+EXT+"$", re.MULTILINE)
                d = listdir(os.getcwd())
                d.sort()
                for f in d:
                    if test.match(f):
                        TSTs.append(f)

                if CALL.startswith("mal"):
                    Clnt = splitcommand(exe['MAL_Client'][1])
                else:
                    Clnt = []   # cannot happen
                for f in TSTs:
                    returncode = RunIt(Clnt, True, openutf8(f), ClntOut, ClntErr, TIMEOUT)
                    if returncode:
                        break
            elif CALL in ["sql", "sqlXs"]:
                TSTs = []
                if CALL == "sql":
                    X=""
                else:
                    X="_s[0-9][0-9]"
                test = re.compile("^"+TST+X+EXT+"$", re.MULTILINE)
                d = listdir(os.getcwd())
                d.sort()
                for f in d:
                    if test.match(f):
                        TSTs.append(f)

                Clnt = splitcommand(exe['SQL_Client'][1])
                if user:
                    Clnt.append('-u%s' % user)
                if passwd:
                    Clnt.append('-P%s' % passwd)
                for f in TSTs:
                    returncode = RunIt(Clnt, True, openutf8(f), ClntOut, ClntErr, TIMEOUT)
                    if returncode:
                        break
            elif CALL == "R":
                Clnt = splitcommand(exe['R_Client'][1])
                RunIt(Clnt, False, openutf8(TST+EXT), ClntOut, ClntErr, TIMEOUT)
            elif CALL == "ruby":
                Clnt = splitcommand(exe['ruby_client'][1]) + [TST + EXT]

                Clnt[2], Clnt[1] = Clnt[1], Clnt[2]
                Clnt.append(env['TSTDB'])

                RunIt(Clnt, True, "", ClntOut, ClntErr, TIMEOUT)
        else:
            for fp in ClntOut,ClntErr:
                fp.write('\n\n! Server not ready; skipping attempt to start client!\n\n')
        ClntOut.close()
        ClntErr.close()
    finally:
        if SERVER in ["MAL", "SQL"] and pSrvr is not None:
            if PSRVR is None and pSrvr.started:
                pSrvr.terminate()
                if procdebug:
                    print('DoIt: process exited "%s" (%s)\n' % ('" "'.join(Srvr), pSrvr.code))

            AllOut = [SrvrOut, ClntOutFile]
            AllErr = [SrvrErr, ClntErrFile]
            TestOut = openutf8(TestOutFile, 'a')
            for q in AllOut:
                if type(q) is type(''):
                    n = q
                else:
                    n = q.name
                    q.close()
                q = openutf8(n, 'r')
                try:
                    TestOut.write(q.read())
                except IOError as err:
                    Warn("Reading from input '%s' or writing to output '%s' failed with #%d: '%s'." % (q.name, TestOut.name, err.errno, err.strerror))
                except MemoryError:
                    Warn("Reading from input '%s' or writing to output '%s' failed with 'MemoryError'." % (q.name, TestOut.name))
                TestOut.flush()
                q.close()
            TestErr = openutf8(TestErrFile, 'a')
            for q in AllErr:
                if type(q) is type(''):
                    n = q
                else:
                    n = q.name
                    q.close()
                q = openutf8(n,'r')
                TestErr.write(q.read())
                TestErr.flush()
                q.close()
        else:
            TestOut = try_open(TestOutFile, 'a')
            TestErr = try_open(TestErrFile, 'a')

    if returncode is None and pSrvr is not None:
        returncode = pSrvr.code # can still be None
    if returncode is not None:
        # something failed
        if returncode == 'interrupt':
            raise KeyboardInterrupt
        for err in ('timeout', 'segfault', 'abort', 'signal', 'error'):
            if returncode == err:
                return err
        return returncode       # remaining error (shouldn't get here)

    if CALL not in ('python', 'other', 'ruby'):
        # running mserver/mclient directly, so we know they didn't fail
        return None

    # Try to detect segfaults and the like
    # Try to detect aborts due to too deep recursion
    for (regexp, msg) in [("(^(|[^#]*[\t ])((Memory|Segmentation) [Ff]ault|Bus [Ee]rror|Aborted|Assertion (|.* )failed[:\.]|!FATAL: BATSIGabort:)([ \t]|$))",
                           'segfault'),
                          ("aborted too deep recursion",
                           'recursion'),
                          ("mal_mapi\.listen:operation failed: bind to stream socket port",
                           'socket')]:
        TO = re.compile(regexp, re.MULTILINE)
        # FIXME: this begs for a much nicer solution (100% copy of below)
        for f in (TestErrFile, TestOutFile):
            if os.path.isfile(f):
                for l in openutf8(f):
                    if TO.search(l):
                        return msg

    return None

### DoIt(env, SERVER, CALL, TST, EXT, TestOutFile, TestErrFile, STIMEOUT, CTIMEOUT, TIMEOUT, MAPIsockets, length, nomito) #

def Check(command, input) :
    global setpgrp
    if procdebug:
        print('Check: starting process "%s" (inpipe,outpipe,errpipe)\n' % '" "'.join(command))
    setpgrp = True
    proc = process.Popen(command, stdin=process.PIPE, stdout=process.PIPE,
                         stderr=process.PIPE, text=True)
    proc.killed = False
    proc.onechild = True
    t = Timer(float(par['TIMEOUT']), killProc, args = [proc])
    try:
        t.start()
        qOut, qErr = proc.communicate(input = input)
        t.cancel()
        if procdebug:
            print('Check: process exited "%s" (%s)\n' % ('" "'.join(command), proc.returncode))
    except KeyboardInterrupt:
        t.cancel()
        killProc(proc)
        if procdebug:
            print('Check: process killed "%s"\n' % '" "'.join(command))
        raise
    qOut = qOut.split('\n')
    qErr = qErr.split('\n')
    failed = False
    if proc.returncode:
        qOut.append('! Exit 1')
        failed = True
    test = re.compile( r"^!WARNING: BATpropcheck: "                                          "|"
                       r"^!WARNING: monet_checkbat: "                                        "|"
                       r"^!WARNING: GDKlockHome: ignoring empty or invalid .gdk_lock."       "|"
                       r"^!WARNING: BBPdir: initializing BBP.",
                       re.MULTILINE)
    noErr = []
    for l in qOut+qErr:
        if l.startswith("!"):
            if test.match(l):
                if not l.startswith("!WARNING: "):
                    noErr.append(l+"\n")
            else:
                ErrMsg('"%s" failed:' % '" "'.join(command))
                failed = True
                if qOut and qOut[-1].startswith("! Exit 1"):
                    qErr.append(qOut.pop())
                for l in qOut+qErr:
                    STDERR.write(l)
                    STDERR.write("\n")
                STDERR.write("\n")
                STDERR.flush()
                #sys.exit(1)
    if noErr:
        STDOUT.flush()
        STDERR.writelines(noErr)
        STDERR.flush()
    return failed
### Check(command, input) #

def CheckClassPath() :
    if 'CLASSPATH' in os.environ:
        cp = os.environ['CLASSPATH']
        cpx = cp + os.pathsep
    else:
        cp = ''
        cpx = ''
    JARS = {
        'HAVE_MONETDBJDBC_JAR' : re.compile('^monetdb-jdbc-[0-9]\.[0-9]+(-[a-f0-9]{12})?\.jre[0-9]+\.jar$'),
        'HAVE_JDBCCLIENT_JAR'  : re.compile('^jdbcclient\.jre[0-9]+\.jar$'),
        'HAVE_JDBCTESTS_JAR'   : re.compile('^jdbctests\.jar$'),
    }
    # check for known JARs in CLASSPATH files
    for p in cp.split(os.pathsep):
        if os.path.isdir(p):
            for f in os.listdir(p):
                if not f.endswith('.jar'):
                    continue
                for C in JARS:
                    if JARS[C].match(f):
                        CONDITIONALS[C] = '#'
                        cp = os.path.join(p, f) + os.pathsep + cp
                        break
        elif os.path.isfile(p):
            f = os.path.basename(p)
            for C in JARS:
                if JARS[C].match(f):
                    CONDITIONALS[C] = '#'
                    break
    # check for known JARs in CLASSPATH directories
    # + fall-back using pkgdatadir/lib
    cpx += _configure(os.path.join('@QXdatadir@','monetdb','lib'))
    for d in cpx.split(os.pathsep):
        if os.path.isdir(d):
            for f in listdir(d):
                p = os.path.join(d,f)
                if os.path.isfile(p):
                    if f == 'BugConcurrent_clients_SF_1504657.class':
                        C = 'HAVE_JDBCTESTS_DIR'
                        if not CONDITIONALS.get(C):
                            cp = cp + os.pathsep + d
                            CONDITIONALS[C] = '#'
                    else:
                        C = 'HAVE_%s' % f.upper().replace('.','_')
                        if C not in JARS:
                            C = 'HAVE_MONETDBJDBC_JAR'
                        if not CONDITIONALS.get(C) and JARS[C].match(f):
                            cp = cp + os.pathsep + p
                            CONDITIONALS[C] = '#'
    if cp:
        os.environ['CLASSPATH'] = cp
    if verbose:
        miss = ''
        for j in ['monetdbjdbc.jar', 'jdbcclient.jar', 'jdbctests.jar']:
            C = 'HAVE_%s' % j.upper().replace('.','_')
            if not CONDITIONALS.get(C):
                miss += ' "%s"' % j
        if miss:
            Warn('Could not find%s in\nCLASSPATH="%s"' % (miss,cpx))
    if CONDITIONALS.get('HAVE_MONETDBJDBC_JAR') and \
       ( CONDITIONALS.get('HAVE_JDBCTESTS_JAR') or
         CONDITIONALS.get('HAVE_JDBCTESTS_DIR') ):
        CONDITIONALS['HAVE_JDBCTESTS'] = '#'
### CheckClassPath() #

def SetExecEnv(exe,verbose) :
    if os.name == "nt":
        CALL = "call "
    else:
        CALL = ""
    if verbose:
        STDERR.flush()
    for v in exe.keys():
        if v == 'mserver5':
            V = 'MSERVER'
        else:
            V = v.upper()
        if exe[v][0]:
            os.environ[V] = CALL+exe[v][1]
        else:
            os.environ[V] = ""
        if verbose:
            print("%s = %s : %s" % (V, exe[v][0], exe[v][1]))
    if verbose:
        STDOUT.flush()
### SetExecEnv(exe,procdebug) #


#############################################################################
#       MAIN

THISFILE = os.path.basename(sys.argv[0])
THISPATH = os.path.realpath(os.path.dirname(sys.argv[0]))
TSTDBG = str(2+8)
TSTTHREADS = "0"
dftTSTPREF = "mTests"
TSTSUFF = "Tests"

if os.name != 'nt' and hasattr(os, "symlink"):
    SymlinkOrCopy = os.symlink
    listdir = os.listdir
else:
    def SymlinkOrCopy(src, dst):
        shutil.copy(os.path.normpath(os.path.join(os.getcwd(), src)), dst)
    def listdir(d):
        return os.listdir(os.path.abspath(d))

HOST = 'localhost'
if 'HOST' in os.environ:
    HOST = os.environ['HOST']
#else:
#    HOST = ''
elif os.name != "nt":
    HOST = os.uname()[1]
elif 'COMPUTERNAME' in os.environ:
    HOST = os.environ['COMPUTERNAME']
##else:
##    HOST = "WIN2000"
if 'DOMAIN' in os.environ:
    HOST = HOST.replace('.'+os.environ('DOMAIN'),'')
else:
    HOST = HOST.split('.', 1)[0]
os.environ['HOST'] = HOST
# check the host port actually works
_, HOST = randomPort(30000,39999)
os.environ['HOST'] = HOST
os.environ['MAPIHOST'] = HOST

if os.name == "nt":
    SYST    = "Windows"
    RELEASE = "5.0"
    r = re.compile('^Microsoft Windows (.*)\[Version ([0-9]+\.[0-9]+)([^\[0-9].*)\]$')
    if procdebug:
        print('starting process "cmd" "/c" "ver" (inpipe,outpipe)\n')
    proc = process.Popen('cmd /c ver', stdin=process.PIPE,
                         stdout=process.PIPE, stderr=process.PIPE,
                         text=True)
    qOut, qErr = proc.communicate()
    if procdebug:
        print('process exited "cmd" "/c" "ver" (%s)\n' % proc.returncode)
    for l in qOut.split('\n'):
        m = r.match(l.strip())
        if m and m.group(2):
            RELEASE = m.group(2)
else:
    SYST    = os.uname()[0].split("_NT-", 1)[0].replace("-","")
    if SYST == "AIX":
        RELEASE = os.uname()[3]+"."+os.uname()[2]
    else:
        RELEASE = os.uname()[2].split("(", 1)[0]
        MAJOR = RELEASE.split(".", 1)[0]
        if "A" <= MAJOR and MAJOR <= "Z":
            RELEASE = RELEASE.split(".", 1)[1]

# this is for the wine/mingw setup
if sys.platform == 'linux2' and CONDITIONALS['CROSS_COMPILING']:
    SYST = 'Windows'
    HOST = "WINE"
    RELEASE = "5.2"

# see if we can use UNIX sockets
try:
    server = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
except (socket.error, AttributeError):
    # apparently not
    SOCK = False
else:
    SOCK = True

if SYST == "Linux":
    #  Please keep this aligned / in sync with configure.ag !
    LINUX_DIST=''
    if os.path.isfile('/etc/os-release'):
        l = open('/etc/os-release').read()
        x0 = re.search('^NAME=[\'"]?([^\'"\n]*)[\'"]?$', l, re.MULTILINE)
        if x0:
            x0 = x0.group(1)
        x1 = re.search('^VERSION_ID=[\'"]?([^\'"\n]*)[\'"]?$', l, re.MULTILINE)
        if x1:
            x1 = x1.group(1)
        LINUX_DIST = '%s:%s' % (x0 or 'Linux', x1 or '')
    elif os.path.isfile('/etc/fedora-release'):
        l = open('/etc/fedora-release').readline()
        x = re.match('^.*(Fedora).* release ([0-9][^ \n]*)( .*)*$', l)
        if x:
            LINUX_DIST = '%s:%s' % (x.group(1),x.group(2))
    elif os.path.isfile('/etc/centos-release'):
        l = open('/etc/centos-release').readline()
        x = re.match('^(CentOS).* release ([0-9][^ \n]*)( .*)*$', l)
        if x:
            LINUX_DIST = '%s:%s' % (x.group(1),x.group(2))
    elif os.path.isfile('/etc/yellowdog-release'):
        l = open('/etc/yellowdog-release').readline()
        x = re.match('^(Yellow) Dog Linux release ([0-9][^ \n]*)( .*)*$', l)
        if x:
            LINUX_DIST = '%s:%s' % (x.group(1),x.group(2))
    elif os.path.isfile('/etc/redhat-release'):
        l = open('/etc/redhat-release').readline()
        x0 = re.match('^.*(Red) (Hat).* Linux *([A-Z]*) release ([0-9][^ \n]*)( .*)*$', l)
        x1 = re.match('^Red Hat Enterprise Linux ([AW]S) release ([0-9][^ \n]*)( .*)*$', l)
        x2 = re.match('^(CentOS).* release ([0-9][^ \n]*)( .*)*$', l)
        x3 = re.match('^(Scientific) Linux SL release ([0-9][^ \n]*)( .*)*$', l)
        if x0:
            LINUX_DIST = '%s%s:%s%s' % (x0.group(1),x0.group(2),x0.group(4),x0.group(3))
        elif x1:
            LINUX_DIST = 'RHEL:%s%s' % (x1.group(2),x1.group(1))
        elif x2:
            LINUX_DIST = '%s:%s' % (x2.group(1),x2.group(2))
        elif x3:
            LINUX_DIST = '%s:%s' % (x3.group(1),x3.group(2))
    elif os.path.isfile('/etc/SuSE-release'):
        l = open('/etc/SuSE-release').readline()
        x0 = re.match('^.*(S[Uu]SE) LINUX Enterprise ([SD])[ervsktop]* ([0-9][^ \n]*)( .*)*$', l)
        x1 = re.match('^S[Uu]SE LINUX Enterprise ([SD])[ervsktop]* ([0-9][^ \n]*)( .*)*$', l)
        x2 = re.match('^.*(S[Uu]SE) [Ll][Ii][Nn][Uu][Xx].* ([0-9][^ \n]*)( .*)*$', l)
        x3 = re.match('^open(S[Uu]SE) ([0-9][^ \n]*)( .*)*$', l)
        if x0:
            LINUX_DIST = '%s:%sE%s' % (x0.group(1),x0.group(3),x0.group(2))
        elif x1:
            LINUX_DIST = 'SLE%s:%s' % (x1.group(1),x1.group(2))
        elif x2:
            LINUX_DIST = '%s:%s' % (x2.group(1),x2.group(2))
        elif x3:
            LINUX_DIST = '%s:%s' % (x3.group(1),x3.group(2))
    elif os.path.isfile('/etc/gentoo-release'):
        l = open('/etc/gentoo-release').readline()
        x = re.match('^.*(Gentoo) Base System.* [versionrelease]* ([0-9][^ \n]*)( .*)*$', l)
        if x:
            LINUX_DIST = '%s:%s' % (x.group(1),x.group(2))
    elif os.path.isfile('/etc/lsb-release'):
        x0 = x1 = None
        for l in open('/etc/lsb-release'):
            if not x0:
                x0 = re.match('^DISTRIB_ID=([^ \n]*)( .*)*$', l)
            if not x1:
                x1 = re.match('^DISTRIB_RELEASE=([^ \n]*)( .*)*$', l)
        if x0 and x1:
            LINUX_DIST = '%s:%s' % (x0.group(1),x1.group(1))
    elif os.path.isfile('/etc/debian_version'):
        LINUX_DIST = "Debian:"+open('/etc/debian_version').readline().strip()
    if not LINUX_DIST:
        LINUX_DIST = SYST+':'+re.match('^([0-9\.]*)([^0-9\.].*)$', RELEASE).group(1)
    DIST,VERSION = LINUX_DIST.split(':', 1)
elif SYST == "SunOS" and os.path.isfile('/etc/release'):
    (DIST,VERSION,rest) = open('/etc/release').readline().strip().split(' ',2)
else:
    DIST = SYST
    VERSION = RELEASE

SYSTVER = SYST+RELEASE
DISTVER = DIST+VERSION
os.environ['SYST'] = SYST
os.environ['SYSTVER'] = SYSTVER
os.environ['RELEASE'] = RELEASE
os.environ['DIST'] = DIST
os.environ['DISTVER'] = DISTVER
os.environ['VERSION'] = VERSION


par = {}
dft = {}

def main(argv) :
    #TODO:
    #signal.signal(signal.SIGALRM, AlarmHandler)
    global global_timeout

    VARS = ['TSTSRCBASE', 'TSTTRGBASE']
    VARS = VARS + [ 'MALCLIENT', 'SQLCLIENT', 'SQLDUMP', 'RCLIENT', 'RUBYCLIENT']    #, 'MONETDB_MOD_PATH' ]

    env = {}

    # most intuitive (?) default settings
    dft['TSTSRCBASE']     = r"_configure('@QXSOURCE@')"
    dft['TSTTRGBASE']     = r"_configure('@QXprefix@')"   # or os.getcwd() ?
    dft['GDK_DEBUG']      = "TSTDBG"
    dft['GDK_NR_THREADS'] = "TSTTHREADS"
    dft['MONETDB_MOD_PATH'] = "''"
    dft['setMONETDB_MOD_PATH'] = "'--set \"monet_mod_path='+env['MONETDB_MOD_PATH']+'\"'"
    dft['MAPIPORT']       = "str(randomPort(30000,39999)[0])"
    dft['MALCLIENT']      = "'mclient -lmal -ftest -tnone -Eutf-8'"
    dft['SQLCLIENT']      = "'mclient -lsql -ftest -tnone -Eutf-8'"
    dft['SQLDUMP']        = "'msqldump -q'"
    dft['RUBYCLIENT']     = "'ruby'"

    r_noecho = '--no-echo'
    if CheckExec('R'):
        proc = process.Popen(['R', '--version'],
                             stdout=process.PIPE, stderr=process.PIPE,
                             text=True)
        r_out, r_err = proc.communicate()
        res = re.search(r'R version (?P<major>\d+)\.', r_out)
        if res is not None and int(res.group('major')) < 4:
            r_noecho = '--slave'
        if CONDITIONALS['HAVE_LIBR']:
            proc = process.Popen(['R', r_noecho, '--no-save', '--no-restore',
                                  '-e', 'print(Sys.getenv("R_LIBS_USER"))'],
                                 stdout=process.PIPE, stderr=process.PIPE,
                                 text=True)
            r_out, r_err = proc.communicate()
            res = re.search(r'\[\d+\] "(?P<dir>.*)"', r_out)
            if res is not None:
                rdir = os.path.expanduser(res.group('dir'))
                if not os.path.exists(rdir):
                    os.makedirs(rdir)
    dft['RCLIENT'] = "'R --vanilla {}'".format(r_noecho)

    #par = {}
    # get current environment
    env['HOST'] = os.environ['HOST']
    for v in VARS:
        if v in os.environ:
            env[v] = os.environ[v]
            #TODO:
            # make sure, that PATHs are absolute

    # commandline options overrule environment
    parser = argparse.ArgumentParser(usage='%(prog)s [options] ( [<dir>] [<tests>] | [<dirs>] )', epilog='See %s for details about Mtest.py.' % _configure(os.path.join('@QXSOURCE@','testing','README')))
    parser.add_argument('--version', action='version', version='@VERSION@')
    parser.add_argument('--recursive', '-r', action='store_true', dest='recursive', help="recurse into subdirectories (implies 'All')")
    parser.add_argument('--revision', action='store', dest='revision', metavar='<hgid>', help='use given revision as the HG short hash')
    parser.add_argument('--TSTSRCBASE', action='store', dest='TSTSRCBASE', metavar='<path>', help='default: "%s"' % _configure('@QXSOURCE@'))
    parser.add_argument('--TSTTRGBASE', action='store', dest='TSTTRGBASE', metavar='<path>', help='default: "%s"' % _configure('@QXprefix@'))
    parser.add_argument('--quiet', '-q', action='store_true', dest='quiet', help="suppress messages on stdout")
    parser.add_argument('--verbose', '-v', action='store_true', dest='verbose', help="more verbose test output")
    parser.add_argument('--procdebug', action='store_true', dest='procdebug', help='process debugging (Mtest developers only)')

    parser.add_argument('-t', action='store', dest='timeout', metavar='<sec>', type=int, default=60, help="timeout: kill (hanging) tests after <sec> seconds;\n-t0 means no timeout (default: -t60)")
    parser.add_argument('--debug', '-d', action='store', dest='debug', metavar='<sec>', type=int, default=int(TSTDBG), help="debug value to be used by mserver5 (default: -d%s)\n(see `mserver5 --help' for details)" % TSTDBG)
    parser.add_argument('--nr_threads', '-n', action='store', dest='nr_threads', metavar='<num>', type=int, default=int(TSTTHREADS), help="number of threads for mserver5 (default: -n%s)\n-n0 => mserver5 automatically determines the number of CPU cores" % TSTTHREADS)
    parser.add_argument('--monet_mod_path', action='store', dest='monet_mod_path', metavar='<pathlist>', help="override mserver5's default module search path")
    parser.add_argument('--dbfarm', action='store', dest='gdk_dbfarm', default=_configure(os.path.join('@QXlocalstatedir@','MonetDB')), metavar='<directory>', help="override default location of database directory")
    parser.add_argument('--MALCLIENT', action='store', dest='MALCLIENT', metavar='<mal-client program>', help='default: %s' % dft['MALCLIENT'])
    parser.add_argument('--SQLCLIENT', action='store', dest='SQLCLIENT', metavar='<sql-client program>', help='default: %s' % dft['SQLCLIENT'])
    parser.add_argument('--SQLDUMP', action='store', dest='SQLDUMP', metavar='<sql-dump program>', help='default: %s' % dft['SQLDUMP'])
    parser.add_argument('--RCLIENT', action='store', dest='RCLIENT', metavar='<R program>', help='default: %s' % dft['RCLIENT'])
    parser.add_argument('--RUBYCLIENT', action='store', dest='RUBYCLIENT', metavar='<ruby program>', help='default: %s' % dft['RUBYCLIENT'])
    parser.add_argument('--concurrent', action='store_true', dest='concurrent', help='There are concurrent Mtest runs using the same MonetDB installation')
    parser.add_argument('--dbg', action='store', dest='dbg', metavar='<debugger/valgrind>', help="debugger to start before each server")
    parser.add_argument('--mserver_set', action='store', dest='mserver_set', metavar='<mserver5_option>', help="This passes a single set to the server")
    parser.add_argument('--no-clean', action='store_true', dest='no_clean', help='Do not clean up before test')
    parser.add_argument('--testweb', action='store_true', dest='testweb', help='Optimize testing for testweb')
    parser.add_argument('--releaserun', action='store_true', dest='releaserun', help='run tests as if for a release test')
    parser.add_argument('--multifarm', action='store_true', dest='multifarm', help='use multiple dbfarms (developers only)')
    parser.add_argument('--transient-inmemory', action='store_true', dest='inmemory', help="don't write transient data to disk")
    parser.add_argument('--nomito', action='store_true', dest='nomito', help='Do not pass --forcemito to server')
    parser.add_argument('--addreqs', action='store_true', dest='addreqs', help='automatically add required tests when testing individual tests')
    parser.add_argument('--global_timeout', '-T', action='store', dest='global_timeout', type=int, default=global_timeout, metavar='<sec>', help='global timeout')
    parser.add_argument('--data_path', '-D', action='store', dest='data_path', metavar='<path>', help='Path to the root directory of the data files needed for testing')
    parser.add_argument('--alltests', action='store_true', dest='alltests', help='also run tests that are known to fail')
    parser.add_argument('--initdb', action='store', dest='initdb', metavar='<zipfile>', help='zip file with contents for initial database')

    parser.add_argument('tests', nargs='*', help='The positional arguments are either a list of one or more directories to be tested, or a single directory followed by a list of tests within that directory.')
    parser.add_argument('--auto', action='store_true', help='auto mode wher for each test converted a .test file is created')

    opts = parser.parse_args()
    args = opts.tests

    recursive = opts.recursive
    global testweb
    testweb = False
    global quiet
    quiet = opts.quiet
    global verbose
    verbose = opts.verbose
    if quiet and verbose:
        ErrExit('--verbose and --quiet are mutually exclusive')
    global procdebug
    procdebug = opts.procdebug
    nomito = False
    addreqs = False
    testweb = opts.testweb
    CONDITIONALS['RELEASERUN'] = opts.releaserun
    nomito = opts.nomito
    par['TIMEOUT'] = opts.timeout
    env['GDK_DEBUG'] = str(opts.debug)
    env['GDK_NR_THREADS'] = str(opts.nr_threads)
    a = opts.monet_mod_path
    if a is not None:
        env['MONETDB_MOD_PATH'] = a
    a = opts.gdk_dbfarm
    if a is not None:
        env['GDK_DBFARM'] = a
    a = opts.concurrent
    if a:
        env['CONCURRENT'] = a
    a = opts.dbg
    if a is not None:
        env['DBG'] = a
    a = opts.mserver_set
    if a is not None:
        env['MSERVER_SET'] = "--set " + a
    else:
        env['MSERVER_SET'] = ""
    a = opts.no_clean
    if a:
        env['NOCLEAN'] = a
    a = opts.multifarm
    if a:
        env['MULTIFARM'] = 'True'
    a = opts.inmemory
    if a:
        env['TRANS_INMEM'] = 'True'
    if opts.multifarm and opts.inmemory:
        ErrXit("Cannot have both --multifarm and --transient-inmemory")
    addreqs = opts.addreqs
    a = opts.global_timeout
    if a:
        global_timeout = a
    a = opts.data_path
    if a is not None:
        env['TSTDATAPATH'] = a
    global initdb
    initdb = opts.initdb
    for v in VARS:
        a = vars(opts).get(v)
        if a is not None:
            env[v] = a

    # display par's
    STDERR.flush()
    if verbose:
        for v in par.keys():
            #os.environ[v] = par[v]
            print("%s = %s" % (v, str(par[v])))
    STDOUT.flush()

    python_version = ''
    if CheckExec('python'):
        proc = process.Popen(['python', '-c', 'import sys; print(sys.version[:1])'],
                             stdout=process.PIPE, stderr=process.PIPE,
                             text=True)
        pyout, pyerr = proc.communicate()
        if proc.returncode == 0 and pyout:
            python_version = pyout.strip()
            os.environ['PYTHON' + python_version] = 'python'
    if python_version == '3':
        py3list = ['python']
    else:
        py3list = []
    for py3 in py3list + ['python3', 'python3.7', 'python3.6', 'python3.5', 'python3.4']:
        if CheckExec(py3):
            try:
                proc = process.Popen([py3, '-c', 'import pymonetdb'],
                                     stdout=process.PIPE, stderr=process.PIPE,
                                     text=True)
                pyout, pyerr = proc.communicate()
                if proc.returncode == 0:
                    CONDITIONALS['HAVE_PY3MONETDB'] = '#'
                    os.environ['PYTHON3'] = py3
                    break
            except OSError:
                pass
    else:
        CONDITIONALS['HAVE_PY3MONETDB'] = '' # no pymonetdb for python3
    try:
        import pymonetdb
    except ImportError:
        print('Python available, but pymonetdb package not available')
    else:
        CONDITIONALS['HAVE_PYMONETDB'] = '#'
    try:
        import lz4
    except ImportError:
        CONDITIONALS['HAVE_PYTHON_LZ4'] = False
    else:
        CONDITIONALS['HAVE_PYTHON_LZ4'] = True
    if 'PYTHON3' in os.environ:
        proc = process.Popen([os.environ['PYTHON3'], '-c', 'import scipy'],
                             stdout=process.PIPE, stderr=process.PIPE,
                             text=True)
        pyout, pyerr = proc.communicate()
        if proc.returncode == 0:
            CONDITIONALS['HAVE_LIBSCIPY3'] = '#'
    if env.get('TSTDATAPATH'):
        CONDITIONALS['HAVE_DATA_PATH'] = '#'
    if CheckExec('perl'):
        proc = process.Popen(['perl', '-e', 'use MonetDB::CLI::MapiPP; use DBI;'],
                             stdout=process.PIPE, stderr=process.PIPE,
                             text=True)
        perl_out, perl_err = proc.communicate()
        if proc.returncode == 0:
            CONDITIONALS['HAVE_PERL'] = '#'
    if CheckExec('php'):
        phpcmd = ['php']
        if 'PHP_INCPATH' in os.environ:
            phpcmd.extend(['-d', 'include_path=%s' % os.environ['PHP_INCPATH']])
        phpcmd.extend(['-r', "require 'monetdb/php_monetdb.php';"])
        proc = process.Popen(phpcmd,
                             stdout=process.PIPE, stderr=process.PIPE,
                             text=True)
        php_out, php_err = proc.communicate()
        if proc.returncode == 0:
            CONDITIONALS['HAVE_PHP'] = '#'
    if CheckExec('ruby'):
        # also check ruby version; we require >= 1.9 for "require_relative"
        proc = process.Popen(['ruby', '--version'],
                             stdout=process.PIPE, stderr=process.PIPE,
                             text=True)
        ruby_out, ruby_err = proc.communicate()
        ruby_reg = re.compile("^[^ ]* ([0-9]+)\.([0-9]+)[^0-9].*$", re.MULTILINE)
        ruby_ver = ruby_reg.match(ruby_out)
        if ruby_ver and \
           100 * int(ruby_ver.group(1)) + int(ruby_ver.group(2)) >= 109:
            # now check whether the monetdb-ruby gem is available
            proc = process.Popen(['ruby', '-e', "require 'MonetDB'"],
                                 stdout=process.PIPE, stderr=process.PIPE,
                                 text=True)
            ruby_out, ruby_err = proc.communicate()
            if proc.returncode == 0:
                CONDITIONALS['HAVE_RUBY'] = '#'
    CheckClassPath()

    # tidy-up and fall-back to defaults where necessary
    vars_ = VARS + ['MAPIPORT', 'GDK_DEBUG', 'GDK_NR_THREADS', 'MONETDB_MOD_PATH']
    for v in vars_:
        if v not in env:
            env[v] = eval(dft[v])

    if env['MAPIPORT'] == 0:
        ErrXit('Cannot find a workable MAPIPORT')
    if env['MONETDB_MOD_PATH']:
        env['setMONETDB_MOD_PATH'] = eval(dft['setMONETDB_MOD_PATH'])
    else:
        env['setMONETDB_MOD_PATH'] = ''
    if 'DBG' in env:
        env['setDBG'] = env['DBG']
    else:
        env['setDBG'] = ''

    # ensure consistent TSTSRCBASE
    if os.path.basename(env['TSTSRCBASE']) == TSTSUFF and \
            os.path.isfile(os.path.join(env['TSTSRCBASE'], "All")):
        ErrXit('TSTSRCBASE itself must not be a test-directory, i.e., called "%s" and contain an "All" file!' % TSTSUFF)

    # make TSTxxxBASE absolute physical paths
    for p in 'TSTSRCBASE', 'TSTTRGBASE':
        if os.path.isdir(env[p]):
            rp = os.path.realpath(env[p])
            if verbose and os.path.normcase(rp) != os.path.normcase(env[p]):
                Warn("%s: Replacing logical path  %s  by absolute physical path  %s" % (p, env[p], rp))
            env[p] = rp
        else:
            ErrXit("Illegal "+p+": directory '"+env[p]+"' does not exist!")


    global TSTTRGBASE
    TSTTRGBASE = env['TSTTRGBASE']
    global TSTSRCBASE
    TSTSRCBASE = env['TSTSRCBASE']
    global TSTDATAPATH
    TSTDATAPATH = env.get('TSTDATAPATH')

    env['TSTPREF'] = dftTSTPREF
    global TSTPREF
    TSTPREF = env['TSTPREF']

    # check whether we have a Mercurial clone
    BACK = os.getcwd()
    try:
        os.chdir(TSTSRCBASE)
        proc = process.Popen(['hg', 'root'],
                             stdout=process.PIPE, stderr=process.PIPE,
                             text=True)
        out, err = proc.communicate()
        if proc.returncode == 0:
            CONDITIONALS['MERCURIAL'] = '#' # True
        proc = None
    except:
        pass
    os.chdir(BACK)

    # check whether our hostname makes sense
    if os.environ['HOST'] == 'localhost':
        CONDITIONALS['BAD_HOSTNAME'] = '#' # True
    else:
        try:
            socket.getaddrinfo(socket.gethostname(), None)
        except:
            CONDITIONALS['BAD_HOSTNAME'] = '#' # True

    s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)
    try:
        s.bind(('::1', int(env['MAPIPORT'])))
    except socket.error as err:
        CONDITIONALS['HAVE_IPV6'] = '' # False
    else:
        CONDITIONALS['HAVE_IPV6'] = '#' # True
    s.close()


    # some relative path's for relocatable HTML output
    RELSRCBASE = os.path.relpath(TSTSRCBASE, TSTTRGBASE)
    env['RELSRCBASE'] = RELSRCBASE

    env['BINDIR'] = _configure('@QXbindir@')
    vars_.append('BINDIR')
    env['LIBDIR'] = _configure('@QXlibdir@')
    vars_.append('LIBDIR')

    # export and display env
    STDERR.flush()
    vars_ = vars_ + ['GDK_DBFARM']
    vars_ = vars_ + ['setMONETDB_MOD_PATH']
    vars_ = vars_ + ['TSTDATAPATH']
    for v in vars_:
        if v in env:
            os.environ[v] = env[v]
            if verbose:
                print("%s = %s" % (v, env[v]))
    if verbose or testweb:
        print("%s = %s" % ('PATH', os.environ['PATH']))
        if 'PYTHONPATH' in os.environ:
            print("%s = %s" % ('PYTHONPATH', os.environ['PYTHONPATH']))
        if 'CLASSPATH' in os.environ:
            print("%s = %s" % ('CLASSPATH', os.environ['CLASSPATH']))
    if testweb:
        for v in ['BINDIR']:
            if v in os.environ:
                print("%s = %s" % (v, os.environ[v]))
    STDOUT.flush()

    # add QUIET par to env
    env['QUIET'] = quiet

    global REV
    REV = opts.revision
    if REV is None:             # no --revision option: try to find out
        try:
            proc = process.Popen(['hg', 'id', '-i'],
                                 stdout=process.PIPE,
                                 text=True)
            out, err = proc.communicate()
            if proc.returncode == 0:
                REV = out.strip()
            proc = None
        except:
            pass
    if REV:
        os.environ['REVISION'] = REV

    global SOCK, HOST
    try:                        # try/finally to clean up sockdir
        # check for executables, set their standard options and export them
        if SOCK:
            # we cannot put the UNIX socket in the mtest root, because that
            # makes the UNIX socket too long on most platforms, so use
            # /var/tmp/mtest and try not to forget to clean that up
            sockdir = "/var/tmp/mtest-%d" % os.getpid()
            try:
                os.mkdir(sockdir);
                SOCK = "--set mapi_usock=%s/.s.monetdb.%s" % \
                        (sockdir, env['MAPIPORT'])
                HOST = sockdir
                os.environ['MAPIHOST'] = HOST
            except:
                SOCK = ""
        else:
            SOCK = ""

        exe = {}
        exe['mserver5']       = CheckExec('mserver5')     , '%s mserver5 --debug=%s --set gdk_nr_threads=%s %s --set mapi_listenaddr=all --set mapi_port=%s %s %s %s' % \
                                                               (env['setDBG'], env['GDK_DEBUG'], env['GDK_NR_THREADS'], env['setMONETDB_MOD_PATH'], env['MAPIPORT'], SOCK, not nomito and '--forcemito' or '', env['MSERVER_SET'])
        exe['python']        = CheckExec(sys.executable) , sys.executable
        exe['ruby_client']   = CheckExec(env['RUBYCLIENT'].split(None, 1)[0])   , '%s %s' % (env['RUBYCLIENT'], env['MAPIPORT'])
        exe['MAL_Client']    = CheckExec(env['MALCLIENT'].split(None, 1)[0])  , '%s --host=%s --port=%s' % (env['MALCLIENT'], HOST, env['MAPIPORT'])
        exe['SQL_Client']    = CheckExec(env['SQLCLIENT'].split(None, 1)[0])   , '%s -i -e --host=%s --port=%s' % (env['SQLCLIENT'], HOST, env['MAPIPORT'])
        exe['SQL_Dump']      = CheckExec(env['SQLDUMP'].split(None, 1)[0])     , '%s --host=%s --port=%s' % (env['SQLDUMP'], HOST, env['MAPIPORT'])
        exe['R_Client']   = CheckExec(env['RCLIENT'].split(None, 1)[0])   , '%s --args %s' % (env['RCLIENT'], env['MAPIPORT'])
        env['exe'] = exe
        SetExecEnv(exe,verbose)


        # parse commandline arguments

        BUSY_PORTS = []

        if not env.get('NOCLEAN') and os.path.exists(os.path.join(TSTTRGBASE, TSTPREF)):
            try:
                shutil.rmtree(os.path.join(TSTTRGBASE, TSTPREF))
            except:
                ErrXit("Failed to remove %s" % os.path.join(TSTTRGBASE, TSTPREF))
        if not os.path.exists(env['GDK_DBFARM']):
            #TODO: set mode to umask
            os.makedirs(env['GDK_DBFARM'])

        if not env.get('NOCLEAN') and os.path.exists(os.path.join(env['GDK_DBFARM'], TSTPREF)):
            try:
                shutil.rmtree(os.path.join(env['GDK_DBFARM'], TSTPREF))
            except:
                ErrXit("Failed to remove %s" % os.path.join(env['GDK_DBFARM'], TSTPREF))
        try:
            os.makedirs(os.path.join(env['GDK_DBFARM'], TSTPREF))
        except os.error:
            if not env.get('NOCLEAN'):
                ErrXit("Failed to create %s" % os.path.join(env['GDK_DBFARM'], TSTPREF))

        try:
            os.makedirs(os.path.join(TSTTRGBASE, TSTPREF))
        except os.error:
            if not env.get('NOCLEAN'):
                ErrXit("Failed to create %s" % os.path.join(TSTTRGBASE, TSTPREF))

        # write .monetdb file for mclient to do authentication with
        dotmonetdbfile = os.path.join(TSTTRGBASE, ".monetdb")
        dotmonetdb = openutf8(dotmonetdbfile, 'w')
        dotmonetdb.write('user=monetdb\n')
        dotmonetdb.write('password=monetdb\n')
        dotmonetdb.close()
        # and make mclient find it
        os.environ['DOTMONETDBFILE'] = dotmonetdbfile

        env['TST_MODS'] = []
        env['TST_BITS'] = ""
        env['TST_INT128'] = ""
        env['TST_SINGLE'] = ""
        env['TST_THREADS'] = ""
        env['TST_ARCH'] = ""
        if GetBitsAndModsAndThreads(env):
            sys.exit(1)
        STDERR.flush()
        if verbose:
            print("Bits: " + env['TST_BITS'])
            print("Arch: " + env['TST_ARCH'])
            if env['TST_INT128']:
                print("Integers: 128bit")
            print("Modules: " + str(env['TST_MODS']))
        STDOUT.flush()

        port = int(env['MAPIPORT'])
        busy, host, Serrno, Serrstr, S = CheckPort(port)
        S[0].close()
        S[1].close()
        if busy:
            Warn("Skipping MAPI tests as MAPIPORT=%s is not available on %s (Error #%d: '%s')!" % (env['MAPIPORT'],host,Serrno,Serrstr))
            BUSY_PORTS.append('MAPI')

        env['BUSY_PORTS'] = BUSY_PORTS
        env['SYST'] = os.environ['SYST']
        env['RELEASE'] = os.environ['RELEASE']
        env['DIST'] = os.environ['DIST']
        env['VERSION'] = os.environ['VERSION']

        STDERR.flush()
        try:
            test_ctx = build_work_ctx(*args) if len(args) > 0 else build_work_ctx(TSTSRCBASE)
        except ValueError as e:
            raise SystemExit(e)
        folders = test_ctx.get('test_folders', [])
        if len(folders) > 1:
            raise SystemExit('ERROR: squash only one test folder at the time')
        if len(folders) == 0:
            raise SystemExit('ERROR: no valid test folder')

        PerformDir(env, folders.pop(), auto=opts.auto)

    except Exception as e:
        raise SystemExit(e)

### main(argv) #

if __name__ == "__main__":
    if '--debug' in sys.argv:
        sys.argv.remove('--debug')
        import pdb
        pdb.run('main(sys.argv)')
    else:
        main(sys.argv)

#       END
#############################################################################
